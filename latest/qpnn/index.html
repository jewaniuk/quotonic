
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="A platform for performing efficient simulations of nonlinear quantum photonic circuits.">
      
      
        <meta name="author" content="Jacob Ewaniuk">
      
      
        <link rel="canonical" href="https://jewaniuk.github.io/quotonic/latest/qpnn/">
      
      
        <link rel="prev" href="../nl/">
      
      
        <link rel="next" href="../trainer/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.22">
    
    
      
        <title>qpnn - quotonic</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.84d31ad4.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../assets/_mkdocstrings.css">
    
      <link rel="stylesheet" href="https://unpkg.com/katex@0/dist/katex.min.css">
    
      <link rel="stylesheet" href="../styles/extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent="custom">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#quotonic.qpnn.QPNN" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <div data-md-color-scheme="default" data-md-component="outdated" hidden>
        
      </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="quotonic" class="md-header__button md-logo" aria-label="quotonic" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            quotonic
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              qpnn
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent="custom"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="custom"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
    
      <div class="md-header__source">
        <a href="https://github.com/jewaniuk/quotonic" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    jewaniuk/quotonic
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../fock/" class="md-tabs__link">
        
  
  
    
  
  fock

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../clements/" class="md-tabs__link">
        
  
  
    
  
  clements

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../aa/" class="md-tabs__link">
        
  
  
    
  
  aa

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../nl/" class="md-tabs__link">
        
  
  
    
  
  nl

      </a>
    </li>
  

      
        
  
  
  
    
  
  
    <li class="md-tabs__item md-tabs__item--active">
      <a href="./" class="md-tabs__link">
        
  
  
    
  
  qpnn

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../trainer/" class="md-tabs__link">
        
  
  
    
  
  trainer

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../training_sets/" class="md-tabs__link">
        
  
  
    
  
  training_sets

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../perm/" class="md-tabs__link">
        
  
  
    
  
  perm

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../logic/" class="md-tabs__link">
        
  
  
    
  
  logic

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../utils/" class="md-tabs__link">
        
  
  
    
  
  utils

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../types/" class="md-tabs__link">
        
  
  
    
  
  types

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


  

<nav class="md-nav md-nav--primary md-nav--lifted md-nav--integrated" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="quotonic" class="md-nav__button md-logo" aria-label="quotonic" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    quotonic
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/jewaniuk/quotonic" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    jewaniuk/quotonic
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../fock/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    fock
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../clements/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    clements
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../aa/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    aa
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../nl/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    nl
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    qpnn
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    qpnn
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#quotonic.qpnn.QPNN" class="md-nav__link">
    <span class="md-ellipsis">
      QPNN
    </span>
  </a>
  
    <nav class="md-nav" aria-label="QPNN">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.QPNN.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#quotonic.qpnn.IdealQPNN" class="md-nav__link">
    <span class="md-ellipsis">
      IdealQPNN
    </span>
  </a>
  
    <nav class="md-nav" aria-label="IdealQPNN">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.IdealQPNN.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.IdealQPNN.training_set" class="md-nav__link">
    <span class="md-ellipsis">
      training_set
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.IdealQPNN.build" class="md-nav__link">
    <span class="md-ellipsis">
      build
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.IdealQPNN.calc_fidelity" class="md-nav__link">
    <span class="md-ellipsis">
      calc_fidelity
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#quotonic.qpnn.ImperfectQPNN" class="md-nav__link">
    <span class="md-ellipsis">
      ImperfectQPNN
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ImperfectQPNN">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.ImperfectQPNN.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.ImperfectQPNN.training_set" class="md-nav__link">
    <span class="md-ellipsis">
      training_set
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.ImperfectQPNN.imperfections" class="md-nav__link">
    <span class="md-ellipsis">
      imperfections
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.ImperfectQPNN.build" class="md-nav__link">
    <span class="md-ellipsis">
      build
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.ImperfectQPNN.calc_unc_fidelity" class="md-nav__link">
    <span class="md-ellipsis">
      calc_unc_fidelity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.ImperfectQPNN.calc_performance_measures" class="md-nav__link">
    <span class="md-ellipsis">
      calc_performance_measures
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#quotonic.qpnn.TreeQPNN" class="md-nav__link">
    <span class="md-ellipsis">
      TreeQPNN
    </span>
  </a>
  
    <nav class="md-nav" aria-label="TreeQPNN">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.TreeQPNN.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.TreeQPNN.training_set" class="md-nav__link">
    <span class="md-ellipsis">
      training_set
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.TreeQPNN.imperfections" class="md-nav__link">
    <span class="md-ellipsis">
      imperfections
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.TreeQPNN.build" class="md-nav__link">
    <span class="md-ellipsis">
      build
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.TreeQPNN.calc_cost" class="md-nav__link">
    <span class="md-ellipsis">
      calc_cost
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.TreeQPNN.calc_overall_performance_measures" class="md-nav__link">
    <span class="md-ellipsis">
      calc_overall_performance_measures
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.qpnn.TreeQPNN.calc_unit_cell_performance_measures" class="md-nav__link">
    <span class="md-ellipsis">
      calc_unit_cell_performance_measures
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../trainer/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    trainer
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../training_sets/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    training_sets
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../perm/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    perm
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../logic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    logic
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../utils/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utils
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../types/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    types
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


  <h1>qpnn</h1>

<div class="doc doc-object doc-module">




    <div class="doc doc-contents first">

        <p>The <code>quotonic.qpnn</code> module includes classes that contain different models of quantum photonic neural networks (QPNNs),
each designed to explore different capabilities in detail. <code>QPNN</code> serves as a template for these models and thus
includes attributes that are relevant to all. The other classes inherit <code>QPNN</code> and build from it, yet remain
organized similarly to each other in many ways, as will be discussed further below.</p>
<p>QPNNs are brain-inspired, nonlinear photonic circuits that have been predicted to near-deterministically (i.e. with
near 100% success rates) generate, and process, quantum entanglement. Driven with light, these networks leverage the
multiplexing, low latency, and ultra-low operational powers of mature photonic integrated circuits similarly to their
classical counterparts. By adding optical nonlinearities to the processing toolkit, QPNNs feature components that not
only induce the necessary photon-photon interactions for efficient processing, but also act analogous to the
activation (i.e. learning) function of conventional neural networks, allowing QPNNs to be trained to perform
specified input-output mappings between quantum photonic states. Building on this operating principle, QPNNs have
been considered for conducting quantum simulation, accelerating quantum state tomography, and even speeding up more
common machine learning tasks like image recognition or natural language processing.</p>
<p>As displayed in the exemplary four-mode, two-layer network shown below, each QPNN is constructed from <span class="arithmatex">\(m\)</span> optical
modes and <span class="arithmatex">\(L\)</span> layers, where each layer is realized by a linear, rectangular <span class="arithmatex">\(m\times m\)</span> Mach-Zehnder inteferometer
(MZI) mesh. By selecting the two controllable phase shifters <span class="arithmatex">\((\phi, \theta)\)</span> in each MZI, each layer can be
programmed to perform any arbitrary linear unitary transformation <span class="arithmatex">\(\mathbf{U}\)</span> on the optical modes of the photons
(see <a href="../clements/">clements</a> for more details). Single-site few-photon optical nonlinearities <span class="arithmatex">\(\Sigma(\varphi)\)</span>,
of effective nonlinear phase shift <span class="arithmatex">\(\varphi\)</span> (ideally <span class="arithmatex">\(\pi\)</span>, see <a href="../nl/">nl</a> for more details), are placed between
consecutive layers. These elements are key to network operation as they provide the learning capabilities to the
neural network and allow it to realize near-deterministic entangling operations.</p>
<p align="center">
<img width="800" src="..img/light/qpnn.png" class="only-light">
<img width="800" src="..img/dark/qpnn.png" class="only-dark">
</p>

<p>By simply piecing all the sections of the network together, a QPNN can be described by the transfer function,</p>
<div class="arithmatex">\[ \mathbf{S} = \mathbf{U}(\boldsymbol{\phi}_L, \boldsymbol{\theta}_L) \cdot \prod_{i = 1}^{L - 1} \boldsymbol{
\Sigma}(\varphi) \cdot \mathbf{U}(\boldsymbol{\phi}_i, \boldsymbol{\theta}_i), \]</div>
<p>where each <span class="arithmatex">\(\boldsymbol{\phi}_L, \boldsymbol{\theta}_L\)</span> are vectors that contain all the <span class="arithmatex">\(\phi, \theta\)</span> phase
shifts in each MZI for the <span class="arithmatex">\(i^\text{th}\)</span> layer. This transfer function will act on the <span class="arithmatex">\(k^\text{th}\)</span> input state
<span class="arithmatex">\(\left|\mathrm{in}\right\rangle_k\)</span> to produce an output state <span class="arithmatex">\(\left|\mathrm{out}\right\rangle_k = \mathbf{
S}\left|\mathrm{in}\right\rangle_k\)</span>. Comparing the output with the target state <span class="arithmatex">\(\left|\mathrm{
targ}\right\rangle_k\)</span>, (i.e. according to a truth table), the unconditional fidelity (or equivalently the success
rate) for the <span class="arithmatex">\(k^\text{th}\)</span> input-target pair is given by</p>
<div class="arithmatex">\[ \mathcal{F}_k^{(\mathrm{unc})} = \left|{}_k\!\left\langle\mathrm{targ}\right|\mathbf{S}\left|\mathrm{
in}\right\rangle\!{}_k\right|^2, \]</div>
<p>which describes the chance that the network produces the targeted output state for any given input state without
conditions. To train the QPNN, an optimization algorithm maximizes the unconditional fidelity (or equivalently
minimizes the cost/network error <span class="arithmatex">\(\mathcal{C}^{(\mathrm{unc})} = 1 - \mathcal{F}^{(\mathrm{unc})}\)</span>) using the
variational phase shift parameters from its <span class="arithmatex">\(L\)</span> layers (see <a href="../trainer/">trainer</a> for more details on training).</p>
<p>Alternatively, the success of a QPNN operation may be conditioned on the detection of a logical output, that is,
one where the photons are detected in a combination of output modes that corresponds to the qubit encoding scheme. In
the image above, dual-rail encoding for the photonic qubits is considered such that a logical output is one where a
single photon is detected in one of the upper two modes while the other is detected in one of the bottom two modes.
This measure is termed the conditional fidelity  (or equivalently just fidelity) <span class="arithmatex">\(\mathcal{F}_k^{(\mathrm{con})}\)</span>,
each <span class="arithmatex">\(k^\text{th}\)</span> term of which can be multiplied by the corresponding probability that the network produces a
logical output in the computational basis <span class="arithmatex">\(\mathcal{P}_k^{(\mathrm{cb})}\)</span> (or equivalently logical rate),</p>
<div class="arithmatex">\[ \mathcal{F}_k^{(\mathrm{unc})} = \mathcal{F}_k^{(\mathrm{con})}\mathcal{P}_k^{(\mathrm{cb})}, \]</div>
<p>to retrieve the <span class="arithmatex">\(k^\text{th}\)</span> term of the unconditional fidelity.</p>
<p>With this background in mind, the structure of the classes for each QPNN model can be described more clearly. Upon
instantiation, each model prepares all pieces of the network architecture, from the linear layers to the nonlinear
sections, though the specific way that these components are prepared may differ slightly between models. Each class
has a property called <code>training_set</code> that can be used to set and retrieve a training set for an instantiated QPNN.
They also include a method called <code>build</code> to construct the system function <span class="arithmatex">\(\mathbf{S}\)</span> in full. With the system
function and a training set, the aforementioned performance measures can be calculated, and these calculations tend
to make up the remainder of the class methods. All of these properties and methods differ slightly between models
which is why they are not written into the base class <code>QPNN</code> itself. If you decide to use <code>quotonic</code> to perform
research on QPNNs, feel free to develop your own model and a corresponding class to go with it. That is essentially
the best way to use this part of the package from a research standpoint. Also, we'd be happy to add it if it fits the
format appropriately, so please reach out!</p>










  <div class="doc doc-children">















































<div class="doc doc-object doc-class">



<h2 id="quotonic.qpnn.QPNN" class="doc doc-heading">
            <code>QPNN</code>


<a href="#quotonic.qpnn.QPNN" class="headerlink" title="Permanent link">&para;</a></h2>


    <div class="doc doc-contents ">


        <p>Base class for a quantum photonic neural network (QPNN).</p>
<p>This is effectively a template that prepares the most fundamental attributes for any QPNN. Each QPNN is designed to
operate on a certain number of photons, <span class="arithmatex">\(n\)</span> with a certain number of optical modes <span class="arithmatex">\(m\)</span>, and features <span class="arithmatex">\(L\)</span> layers.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.QPNN.n">n</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of photons, <span class="arithmatex">\(n\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.QPNN.m">m</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of optical modes, <span class="arithmatex">\(m\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.QPNN.L">L</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of layers, <span class="arithmatex">\(L\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.QPNN.N">N</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>dimension of the relevant Fock basis for <span class="arithmatex">\(n\)</span> photons and <span class="arithmatex">\(m\)</span> optical modes</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>








              <details class="quote">
                <summary>Source code in <code>src/quotonic/qpnn.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">QPNN</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for a quantum photonic neural network (QPNN).</span>

<span class="sd">    This is effectively a template that prepares the most fundamental attributes for any QPNN. Each QPNN is designed to</span>
<span class="sd">    operate on a certain number of photons, $n$ with a certain number of optical modes $m$, and features $L$ layers.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        n (int): number of photons, $n$</span>
<span class="sd">        m (int): number of optical modes, $m$</span>
<span class="sd">        L (int): number of layers, $L$</span>
<span class="sd">        N (int): dimension of the relevant Fock basis for $n$ photons and $m$ optical modes</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">basis_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;secq&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialization of a QPNN instance.</span>

<span class="sd">        Args:</span>
<span class="sd">            n: number of photons, $n$</span>
<span class="sd">            m: number of optical modes, $m$</span>
<span class="sd">            L: number of layers, $L$</span>
<span class="sd">            basis_type: specifies whether the QPNN is resolved in the first or second-quantized basis</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check that basis_type is valid</span>
        <span class="k">assert</span> <span class="p">(</span><span class="n">basis_type</span> <span class="o">==</span> <span class="s2">&quot;secq&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">basis_type</span> <span class="o">==</span> <span class="s2">&quot;firq&quot;</span><span class="p">),</span> <span class="s2">&quot;Basis type must be &#39;secq&#39; or &#39;firq&#39;&quot;</span>

        <span class="c1"># store the provided properties of the QPNN, compute others</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="n">m</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">L</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">calc_secq_dim</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="k">if</span> <span class="n">basis_type</span> <span class="o">==</span> <span class="s2">&quot;secq&quot;</span> <span class="k">else</span> <span class="n">calc_firq_dim</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-function">


<h3 id="quotonic.qpnn.QPNN.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">basis_type</span><span class="o">=</span><span class="s1">&#39;secq&#39;</span><span class="p">)</span></code>

<a href="#quotonic.qpnn.QPNN.__init__" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Initialization of a QPNN instance.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>n</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of photons, <span class="arithmatex">\(n\)</span></p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>m</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of optical modes, <span class="arithmatex">\(m\)</span></p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>L</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of layers, <span class="arithmatex">\(L\)</span></p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>basis_type</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>specifies whether the QPNN is resolved in the first or second-quantized basis</p>
              </div>
            </td>
            <td>
                  <code>&#39;secq&#39;</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/qpnn.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">basis_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;secq&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialization of a QPNN instance.</span>

<span class="sd">    Args:</span>
<span class="sd">        n: number of photons, $n$</span>
<span class="sd">        m: number of optical modes, $m$</span>
<span class="sd">        L: number of layers, $L$</span>
<span class="sd">        basis_type: specifies whether the QPNN is resolved in the first or second-quantized basis</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check that basis_type is valid</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">basis_type</span> <span class="o">==</span> <span class="s2">&quot;secq&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">basis_type</span> <span class="o">==</span> <span class="s2">&quot;firq&quot;</span><span class="p">),</span> <span class="s2">&quot;Basis type must be &#39;secq&#39; or &#39;firq&#39;&quot;</span>

    <span class="c1"># store the provided properties of the QPNN, compute others</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">=</span> <span class="n">m</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">L</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">calc_secq_dim</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="k">if</span> <span class="n">basis_type</span> <span class="o">==</span> <span class="s2">&quot;secq&quot;</span> <span class="k">else</span> <span class="n">calc_firq_dim</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>




  </div>

    </div>

</div>






<div class="doc doc-object doc-class">



<h2 id="quotonic.qpnn.IdealQPNN" class="doc doc-heading">
            <code>IdealQPNN</code>


<a href="#quotonic.qpnn.IdealQPNN" class="headerlink" title="Permanent link">&para;</a></h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="QPNN (quotonic.qpnn.QPNN)" href="#quotonic.qpnn.QPNN">QPNN</a></code></p>


        <p>Class for an idealized QPNN based on single-site Kerr-like nonlinearities.</p>
<p>Here, the QPNN is modelled as it was originally proposed in <a href="https://doi.org/10.1038/s41534-019-0174-7">G. R. Steinbrecher <em>et al</em>., “Quantum optical
neural networks”, <em>npj Quantum Inf</em> <strong>5</strong>, 60 (2019)</a>. Linear layers are
spatial meshes of Mach-Zehnder interferometers, and the single-site nonlinearities are based on the optical Kerr
effect. A provided truth table defines the training set.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.IdealQPNN.n">n</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of photons, <span class="arithmatex">\(n\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.IdealQPNN.m">m</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of optical modes, <span class="arithmatex">\(m\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.IdealQPNN.L">L</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of layers, <span class="arithmatex">\(L\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.IdealQPNN.N">N</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>dimension of the second quantization Fock basis for <span class="arithmatex">\(n\)</span> photons and <span class="arithmatex">\(m\)</span> optical modes</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.IdealQPNN.mesh">mesh</span></code></td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="Mesh (quotonic.clements.Mesh)" href="../clements/#quotonic.clements.Mesh">Mesh</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>object containing methods that allow linear layers (i.e. rectangular Mach-Zehnder interferometer
meshes) to be encoded</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.IdealQPNN.transformer">transformer</span></code></td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="SecqTransformer (quotonic.aa.SecqTransformer)" href="../aa/#quotonic.aa.SecqTransformer">SecqTransformer</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>object containing methods that compute multi-photon unitary transformations
of the linear layers</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.IdealQPNN.varphi">varphi</span></code></td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>effective nonlinear phase shift, <span class="arithmatex">\(\varphi\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.IdealQPNN.kerr">kerr</span></code></td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(N\times N\)</span> array, the matrix representation of the set of single-site Kerr-like
nonlinearities resolved in the second quantization Fock basis</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.IdealQPNN.K">K</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of input-target state pairs in the QPNN training set, defaults to 0 if none provided</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.IdealQPNN.psi_in">psi_in</span></code></td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(K\times N\)</span> array containing the <span class="arithmatex">\(K\)</span> input states in the QPNN training set, resolved in
the <span class="arithmatex">\(N\)</span>-dimensional second quantization Fock basis, defaults to an empty array if none provided</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.IdealQPNN.psi_targ">psi_targ</span></code></td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(K\times N\)</span> array containing the <span class="arithmatex">\(K\)</span> target states in the QPNN training set, resolved
in the <span class="arithmatex">\(N\)</span>-dimensional second quantization Fock basis, defaults to an empty array if none provided</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>








              <details class="quote">
                <summary>Source code in <code>src/quotonic/qpnn.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">IdealQPNN</span><span class="p">(</span><span class="n">QPNN</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class for an idealized QPNN based on single-site Kerr-like nonlinearities.</span>

<span class="sd">    Here, the QPNN is modelled as it was originally proposed in [G. R. Steinbrecher *et al*., “Quantum optical</span>
<span class="sd">    neural networks”, *npj Quantum Inf* **5**, 60 (2019)](https://doi.org/10.1038/s41534-019-0174-7). Linear layers are</span>
<span class="sd">    spatial meshes of Mach-Zehnder interferometers, and the single-site nonlinearities are based on the optical Kerr</span>
<span class="sd">    effect. A provided truth table defines the training set.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        n (int): number of photons, $n$</span>
<span class="sd">        m (int): number of optical modes, $m$</span>
<span class="sd">        L (int): number of layers, $L$</span>
<span class="sd">        N (int): dimension of the second quantization Fock basis for $n$ photons and $m$ optical modes</span>
<span class="sd">        mesh (Mesh): object containing methods that allow linear layers (i.e. rectangular Mach-Zehnder interferometer</span>
<span class="sd">            meshes) to be encoded</span>
<span class="sd">        transformer (SecqTransformer): object containing methods that compute multi-photon unitary transformations</span>
<span class="sd">            of the linear layers</span>
<span class="sd">        varphi (float): effective nonlinear phase shift, $\\varphi$</span>
<span class="sd">        kerr (jnp_ndarray): $N\\times N$ array, the matrix representation of the set of single-site Kerr-like</span>
<span class="sd">            nonlinearities resolved in the second quantization Fock basis</span>
<span class="sd">        K (int): number of input-target state pairs in the QPNN training set, defaults to 0 if none provided</span>
<span class="sd">        psi_in (jnp_ndarray): $K\\times N$ array containing the $K$ input states in the QPNN training set, resolved in</span>
<span class="sd">            the $N$-dimensional second quantization Fock basis, defaults to an empty array if none provided</span>
<span class="sd">        psi_targ (jnp_ndarray): $K\\times N$ array containing the $K$ target states in the QPNN training set, resolved</span>
<span class="sd">            in the $N$-dimensional second quantization Fock basis, defaults to an empty array if none provided</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">varphi</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">training_set</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialization of an Ideal QPNN instance.</span>

<span class="sd">        Each piece of the QPNN architecture is instantiated and stored as an attribute alongside relevant parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">            n: number of photons, $n$</span>
<span class="sd">            m: number of optical modes, $m$</span>
<span class="sd">            L: number of layers, $L$</span>
<span class="sd">            varphi: effective nonlinear phase shift, $\\varphi$</span>
<span class="sd">            training_set: a tuple including two $K\\times N$ arrays, the first of which contains $K$ input states</span>
<span class="sd">                resolved in the second quantization Fock basis, the second of which contains the corresponding</span>
<span class="sd">                target states</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>

        <span class="c1"># instantiate a Clements mesh to act as the pathway to encoding the linear layers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="c1"># instantiate transfomer required for the multi-photon unitary transformations of the linear layers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transformer</span> <span class="o">=</span> <span class="n">SecqTransformer</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

        <span class="c1"># store the provided effective nonlinear phase shift, construct the corresponding nonlinear Kerr-like unitary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">varphi</span> <span class="o">=</span> <span class="n">varphi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kerr</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">build_kerr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">varphi</span><span class="p">))</span>

        <span class="c1"># prepare the training set attributes whether one was provided or not</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">training_set</span> <span class="o">=</span> <span class="n">training_set</span> <span class="k">if</span> <span class="n">training_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(()),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(()))</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">training_set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np_ndarray</span><span class="p">,</span> <span class="n">np_ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Training set of the QPNN.</span>

<span class="sd">        Returns:</span>
<span class="sd">            psi_in: $K\\times N$ array containing the $K$ input states resolved in the second quantization Fock basis</span>
<span class="sd">            psi_targ: $K\\times N$ array containing the $K$ target states resolved in the second quantization Fock basis</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi_in</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi_targ</span><span class="p">)</span>

    <span class="nd">@training_set</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">training_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tset</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Training set of the QPNN.</span>

<span class="sd">        Args:</span>
<span class="sd">            tset: a tuple including two $K\\times N$ arrays, the first of which contains $K$ input states resolved in</span>
<span class="sd">                the second quantization Fock basis, the second of which contains the corresponding target states</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psi_in</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">tset</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psi_targ</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">tset</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi_in</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi_in</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp_ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build a matrix representation of the QPNN from all its layers and components.</span>

<span class="sd">        This method calculates the system function of the QPNN as introduced at the top of this module.</span>

<span class="sd">        Args:</span>
<span class="sd">            phi: $L\\times m(m-1)/2$ phase shifts, $\\phi$, where the ith row contains those for each MZI in the</span>
<span class="sd">                ith layer</span>
<span class="sd">            theta: $L\\times m(m-1)/2$ phase shifts, $\\theta$, where the ith row contains those for each MZI in the</span>
<span class="sd">                ith layer</span>
<span class="sd">            delta: $L\\times m$ phase shifts, $\\delta$, where the ith row contains those for each mode at the output</span>
<span class="sd">                of the mesh in the ith layer</span>

<span class="sd">        Returns:</span>
<span class="sd">            S: $N\\times N$ array, the matrix representation of the QPNN resolved in the second quantization Fock basis</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># encode the single-photon unitary matrices for each linear layer in the Clements configuration</span>
        <span class="n">single_photon_Us</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">encode</span><span class="p">)(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>

        <span class="c1"># perform the multi-photon unitary transformations for each linear layer</span>
        <span class="n">multi_photon_Us</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">)(</span><span class="n">single_photon_Us</span><span class="p">)</span>

        <span class="c1"># for each linear layer up to the last one, multiply the nonlinear unitary and multi-photon unitary together</span>
        <span class="n">layers</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">PhiU</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">kerr</span> <span class="o">@</span> <span class="n">PhiU</span><span class="p">)(</span><span class="n">multi_photon_Us</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

        <span class="c1"># stack the layers together, including the final linear layer</span>
        <span class="n">layers</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">layers</span><span class="p">,</span> <span class="n">multi_photon_Us</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))))</span>

        <span class="c1"># multiply all the layers together</span>
        <span class="n">S</span><span class="p">:</span> <span class="n">jnp_ndarray</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">matmul</span><span class="p">,</span> <span class="n">layers</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">S</span>

    <span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calc_fidelity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DTypeLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the fidelity of the QPNN.</span>

<span class="sd">        This method calculates the fidelity of the QPNN as introduced at the top of this module. In this idealized</span>
<span class="sd">        model, the logical rate is always unity. Therefore, the unconditional and conditional fidelities are</span>
<span class="sd">        equivalent. This method relies on a training set and will thus throw an error if one has not been provided.</span>

<span class="sd">        Args:</span>
<span class="sd">            phi: $L\\times m(m-1)/2$ phase shifts, $\\phi$, where the ith row contains those for each MZI in the</span>
<span class="sd">                ith layer</span>
<span class="sd">            theta: $L\\times m(m-1)/2$ phase shifts, $\\theta$, where the ith row contains those for each MZI in the</span>
<span class="sd">                ith layer</span>
<span class="sd">            delta: $L\\times m$ phase shifts, $\\delta$, where the ith row contains those for each mode at the output</span>
<span class="sd">                of the mesh in the ith layer</span>

<span class="sd">        Returns:</span>
<span class="sd">            F: fidelity of the QPNN</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check that a training set has been provided</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;No training set was provided for the QPNN.&quot;</span>

        <span class="c1"># construct the QPNN system function</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>

        <span class="c1"># apply the QPNN to the input states to produce the output states</span>
        <span class="n">psi_out</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psi</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">psi</span><span class="p">))(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi_in</span><span class="p">)</span>

        <span class="c1"># compute the fidelity by first computing it for all K input-target pairs, then averaging</span>
        <span class="n">Fs</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psit</span><span class="p">,</span> <span class="n">psio</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">psit</span><span class="p">),</span> <span class="n">psio</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi_targ</span><span class="p">,</span> <span class="n">psi_out</span><span class="p">)</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Fs</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span>

        <span class="k">return</span> <span class="n">F</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-function">


<h3 id="quotonic.qpnn.IdealQPNN.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">varphi</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">training_set</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

<a href="#quotonic.qpnn.IdealQPNN.__init__" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Initialization of an Ideal QPNN instance.</p>
<p>Each piece of the QPNN architecture is instantiated and stored as an attribute alongside relevant parameters.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>n</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of photons, <span class="arithmatex">\(n\)</span></p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>m</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of optical modes, <span class="arithmatex">\(m\)</span></p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>L</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of layers, <span class="arithmatex">\(L\)</span></p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>varphi</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>effective nonlinear phase shift, <span class="arithmatex">\(\varphi\)</span></p>
              </div>
            </td>
            <td>
                  <code><span title="numpy.pi">pi</span></code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>training_set</code>
            </td>
            <td>
                  <code><span title="tuple">tuple</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>a tuple including two <span class="arithmatex">\(K\times N\)</span> arrays, the first of which contains <span class="arithmatex">\(K\)</span> input states
resolved in the second quantization Fock basis, the second of which contains the corresponding
target states</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/qpnn.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">varphi</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">training_set</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialization of an Ideal QPNN instance.</span>

<span class="sd">    Each piece of the QPNN architecture is instantiated and stored as an attribute alongside relevant parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        n: number of photons, $n$</span>
<span class="sd">        m: number of optical modes, $m$</span>
<span class="sd">        L: number of layers, $L$</span>
<span class="sd">        varphi: effective nonlinear phase shift, $\\varphi$</span>
<span class="sd">        training_set: a tuple including two $K\\times N$ arrays, the first of which contains $K$ input states</span>
<span class="sd">            resolved in the second quantization Fock basis, the second of which contains the corresponding</span>
<span class="sd">            target states</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>

    <span class="c1"># instantiate a Clements mesh to act as the pathway to encoding the linear layers</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">Mesh</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

    <span class="c1"># instantiate transfomer required for the multi-photon unitary transformations of the linear layers</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">transformer</span> <span class="o">=</span> <span class="n">SecqTransformer</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="c1"># store the provided effective nonlinear phase shift, construct the corresponding nonlinear Kerr-like unitary</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">varphi</span> <span class="o">=</span> <span class="n">varphi</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">kerr</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">build_kerr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">varphi</span><span class="p">))</span>

    <span class="c1"># prepare the training set attributes whether one was provided or not</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">training_set</span> <span class="o">=</span> <span class="n">training_set</span> <span class="k">if</span> <span class="n">training_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(()),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(()))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>






<div class="doc doc-object doc-attribute">



<h3 id="quotonic.qpnn.IdealQPNN.training_set" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">training_set</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
      <small class="doc doc-label doc-label-writable"><code>writable</code></small>
  </span>

<a href="#quotonic.qpnn.IdealQPNN.training_set" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Training set of the QPNN.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>psi_in</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="np_ndarray = np.ndarray

  
      module-attribute
   (quotonic.types.np_ndarray)" href="../types/#quotonic.types.np_ndarray">np_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(K\times N\)</span> array containing the <span class="arithmatex">\(K\)</span> input states resolved in the second quantization Fock basis</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>psi_targ</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="np_ndarray = np.ndarray

  
      module-attribute
   (quotonic.types.np_ndarray)" href="../types/#quotonic.types.np_ndarray">np_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(K\times N\)</span> array containing the <span class="arithmatex">\(K\)</span> target states resolved in the second quantization Fock basis</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

    </div>

</div>






<div class="doc doc-object doc-function">


<h3 id="quotonic.qpnn.IdealQPNN.build" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">build</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span></code>

<a href="#quotonic.qpnn.IdealQPNN.build" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Build a matrix representation of the QPNN from all its layers and components.</p>
<p>This method calculates the system function of the QPNN as introduced at the top of this module.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>phi</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> phase shifts, <span class="arithmatex">\(\phi\)</span>, where the ith row contains those for each MZI in the
ith layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>theta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> phase shifts, <span class="arithmatex">\(\theta\)</span>, where the ith row contains those for each MZI in the
ith layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>delta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m\)</span> phase shifts, <span class="arithmatex">\(\delta\)</span>, where the ith row contains those for each mode at the output
of the mesh in the ith layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>S</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(N\times N\)</span> array, the matrix representation of the QPNN resolved in the second quantization Fock basis</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/qpnn.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
<span class="k">def</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp_ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Build a matrix representation of the QPNN from all its layers and components.</span>

<span class="sd">    This method calculates the system function of the QPNN as introduced at the top of this module.</span>

<span class="sd">    Args:</span>
<span class="sd">        phi: $L\\times m(m-1)/2$ phase shifts, $\\phi$, where the ith row contains those for each MZI in the</span>
<span class="sd">            ith layer</span>
<span class="sd">        theta: $L\\times m(m-1)/2$ phase shifts, $\\theta$, where the ith row contains those for each MZI in the</span>
<span class="sd">            ith layer</span>
<span class="sd">        delta: $L\\times m$ phase shifts, $\\delta$, where the ith row contains those for each mode at the output</span>
<span class="sd">            of the mesh in the ith layer</span>

<span class="sd">    Returns:</span>
<span class="sd">        S: $N\\times N$ array, the matrix representation of the QPNN resolved in the second quantization Fock basis</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># encode the single-photon unitary matrices for each linear layer in the Clements configuration</span>
    <span class="n">single_photon_Us</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">encode</span><span class="p">)(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>

    <span class="c1"># perform the multi-photon unitary transformations for each linear layer</span>
    <span class="n">multi_photon_Us</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">)(</span><span class="n">single_photon_Us</span><span class="p">)</span>

    <span class="c1"># for each linear layer up to the last one, multiply the nonlinear unitary and multi-photon unitary together</span>
    <span class="n">layers</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">PhiU</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">kerr</span> <span class="o">@</span> <span class="n">PhiU</span><span class="p">)(</span><span class="n">multi_photon_Us</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

    <span class="c1"># stack the layers together, including the final linear layer</span>
    <span class="n">layers</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">layers</span><span class="p">,</span> <span class="n">multi_photon_Us</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))))</span>

    <span class="c1"># multiply all the layers together</span>
    <span class="n">S</span><span class="p">:</span> <span class="n">jnp_ndarray</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">matmul</span><span class="p">,</span> <span class="n">layers</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">S</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>






<div class="doc doc-object doc-function">


<h3 id="quotonic.qpnn.IdealQPNN.calc_fidelity" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">calc_fidelity</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span></code>

<a href="#quotonic.qpnn.IdealQPNN.calc_fidelity" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Calculate the fidelity of the QPNN.</p>
<p>This method calculates the fidelity of the QPNN as introduced at the top of this module. In this idealized
model, the logical rate is always unity. Therefore, the unconditional and conditional fidelities are
equivalent. This method relies on a training set and will thus throw an error if one has not been provided.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>phi</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> phase shifts, <span class="arithmatex">\(\phi\)</span>, where the ith row contains those for each MZI in the
ith layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>theta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> phase shifts, <span class="arithmatex">\(\theta\)</span>, where the ith row contains those for each MZI in the
ith layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>delta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m\)</span> phase shifts, <span class="arithmatex">\(\delta\)</span>, where the ith row contains those for each mode at the output
of the mesh in the ith layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>F</code></td>            <td>
                  <code><span title="jax.typing.DTypeLike">DTypeLike</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>fidelity of the QPNN</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/qpnn.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
<span class="k">def</span><span class="w"> </span><span class="nf">calc_fidelity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DTypeLike</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the fidelity of the QPNN.</span>

<span class="sd">    This method calculates the fidelity of the QPNN as introduced at the top of this module. In this idealized</span>
<span class="sd">    model, the logical rate is always unity. Therefore, the unconditional and conditional fidelities are</span>
<span class="sd">    equivalent. This method relies on a training set and will thus throw an error if one has not been provided.</span>

<span class="sd">    Args:</span>
<span class="sd">        phi: $L\\times m(m-1)/2$ phase shifts, $\\phi$, where the ith row contains those for each MZI in the</span>
<span class="sd">            ith layer</span>
<span class="sd">        theta: $L\\times m(m-1)/2$ phase shifts, $\\theta$, where the ith row contains those for each MZI in the</span>
<span class="sd">            ith layer</span>
<span class="sd">        delta: $L\\times m$ phase shifts, $\\delta$, where the ith row contains those for each mode at the output</span>
<span class="sd">            of the mesh in the ith layer</span>

<span class="sd">    Returns:</span>
<span class="sd">        F: fidelity of the QPNN</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check that a training set has been provided</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;No training set was provided for the QPNN.&quot;</span>

    <span class="c1"># construct the QPNN system function</span>
    <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>

    <span class="c1"># apply the QPNN to the input states to produce the output states</span>
    <span class="n">psi_out</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psi</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">psi</span><span class="p">))(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi_in</span><span class="p">)</span>

    <span class="c1"># compute the fidelity by first computing it for all K input-target pairs, then averaging</span>
    <span class="n">Fs</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psit</span><span class="p">,</span> <span class="n">psio</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">psit</span><span class="p">),</span> <span class="n">psio</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi_targ</span><span class="p">,</span> <span class="n">psi_out</span><span class="p">)</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Fs</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span>

    <span class="k">return</span> <span class="n">F</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>




  </div>

    </div>

</div>






<div class="doc doc-object doc-class">



<h2 id="quotonic.qpnn.ImperfectQPNN" class="doc doc-heading">
            <code>ImperfectQPNN</code>


<a href="#quotonic.qpnn.ImperfectQPNN" class="headerlink" title="Permanent link">&para;</a></h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="QPNN (quotonic.qpnn.QPNN)" href="#quotonic.qpnn.QPNN">QPNN</a></code></p>


        <p>Class for experimental modelling of QPNNs based on single-site Kerr-like nonlinearities.</p>
<p>Here, we add relevant experimental imperfections to the QPNN model including non-uniform photon loss and
imbalanced routing caused by non-ideal directional coupler splitting ratios. This model corresponds to that
presented in <a href="https://doi.org/10.1002/qute.202200125">J. Ewaniuk <em>et al</em>., “Imperfect Quantum Photonic Neural Networks”, <em>Adv Quantum Technol.</em> <strong>6</strong>,
2200125 (2023)</a>. As in <code>IdealQPNN</code>, a provided truth table defines the
training set.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.ImperfectQPNN.n">n</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of photons, <span class="arithmatex">\(n\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.ImperfectQPNN.m">m</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of optical modes, <span class="arithmatex">\(m\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.ImperfectQPNN.L">L</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of layers, <span class="arithmatex">\(L\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.ImperfectQPNN.N">N</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>dimension of the second quantization Fock basis for <span class="arithmatex">\(n\)</span> photons and <span class="arithmatex">\(m\)</span> optical modes</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.ImperfectQPNN.meshes">meshes</span></code></td>
            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple of <span class="arithmatex">\(L\)</span> objects containing methods that allow each linear layer (i.e. rectangular
Mach-Zehnder interferometer meshes) to be encoded</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.ImperfectQPNN.ell_mzi">ell_mzi</span></code></td>
            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>nominal loss for a Mach-Zehnder interferometer in dB, where the first (second) element is the
mean (standard deviation) of a normal distribution from which those for each individual interferometer is
selected</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.ImperfectQPNN.ell_ps">ell_ps</span></code></td>
            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>nominal loss for a phase shifter in dB, where the first (second) element is the mean
(standard deviation) of a normal distribution from which those for each individual output phase shifter
is selected</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.ImperfectQPNN.t_dc">t_dc</span></code></td>
            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>directional coupler splitting ratios (T:R) as decimal values, where the first (second) element is
the mean (standard deviation) of a normal distribution from which those for each individual nominally 50:50
coupler is selected</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.ImperfectQPNN.transformer">transformer</span></code></td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="SecqTransformer (quotonic.aa.SecqTransformer)" href="../aa/#quotonic.aa.SecqTransformer">SecqTransformer</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>object containing methods that compute multi-photon unitary transformations of
the linear layers</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.ImperfectQPNN.varphi">varphi</span></code></td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>effective nonlinear phase shift, <span class="arithmatex">\(\varphi\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.ImperfectQPNN.nl">nl</span></code></td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(N\times N\)</span> array, the matrix representation of a set of single-site Kerr-like nonlinearities
resolved in the second quantization Fock basis</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.ImperfectQPNN.K">K</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of input-target state pairs in the QPNN training set, defaults to 0 if none provided</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.ImperfectQPNN.psi_in">psi_in</span></code></td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(K\times N\)</span> array containing the <span class="arithmatex">\(K\)</span> input states in the QPNN training set, resolved in
the <span class="arithmatex">\(N\)</span>-dimensional second quantization Fock basis, defaults to an empty array if none provided</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.ImperfectQPNN.psi_targ">psi_targ</span></code></td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(K\times N\)</span> array containing the <span class="arithmatex">\(K\)</span> target states in the QPNN training set, resolved
in the <span class="arithmatex">\(N\)</span>-dimensional second quantization Fock basis, defaults to an empty array if none provided</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.ImperfectQPNN.comp_indices">comp_indices</span></code></td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(2^n\)</span>-length array whose elements are the indices of the second quantization Fock
basis where dual-rail encoded computational basis states lie</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>








              <details class="quote">
                <summary>Source code in <code>src/quotonic/qpnn.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">ImperfectQPNN</span><span class="p">(</span><span class="n">QPNN</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class for experimental modelling of QPNNs based on single-site Kerr-like nonlinearities.</span>

<span class="sd">    Here, we add relevant experimental imperfections to the QPNN model including non-uniform photon loss and</span>
<span class="sd">    imbalanced routing caused by non-ideal directional coupler splitting ratios. This model corresponds to that</span>
<span class="sd">    presented in [J. Ewaniuk *et al*., “Imperfect Quantum Photonic Neural Networks”, *Adv Quantum Technol.* **6**,</span>
<span class="sd">    2200125 (2023)](https://doi.org/10.1002/qute.202200125). As in `IdealQPNN`, a provided truth table defines the</span>
<span class="sd">    training set.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        n (int): number of photons, $n$</span>
<span class="sd">        m (int): number of optical modes, $m$</span>
<span class="sd">        L (int): number of layers, $L$</span>
<span class="sd">        N (int): dimension of the second quantization Fock basis for $n$ photons and $m$ optical modes</span>
<span class="sd">        meshes (tuple): tuple of $L$ objects containing methods that allow each linear layer (i.e. rectangular</span>
<span class="sd">            Mach-Zehnder interferometer meshes) to be encoded</span>
<span class="sd">        ell_mzi (tuple): nominal loss for a Mach-Zehnder interferometer in dB, where the first (second) element is the</span>
<span class="sd">            mean (standard deviation) of a normal distribution from which those for each individual interferometer is</span>
<span class="sd">            selected</span>
<span class="sd">        ell_ps (tuple): nominal loss for a phase shifter in dB, where the first (second) element is the mean</span>
<span class="sd">            (standard deviation) of a normal distribution from which those for each individual output phase shifter</span>
<span class="sd">            is selected</span>
<span class="sd">        t_dc (tuple): directional coupler splitting ratios (T:R) as decimal values, where the first (second) element is</span>
<span class="sd">            the mean (standard deviation) of a normal distribution from which those for each individual nominally 50:50</span>
<span class="sd">            coupler is selected</span>
<span class="sd">        transformer (SecqTransformer): object containing methods that compute multi-photon unitary transformations of</span>
<span class="sd">            the linear layers</span>
<span class="sd">        varphi (float): effective nonlinear phase shift, $\\varphi$</span>
<span class="sd">        nl (jnp_ndarray): $N\\times N$ array, the matrix representation of a set of single-site Kerr-like nonlinearities</span>
<span class="sd">            resolved in the second quantization Fock basis</span>
<span class="sd">        K (int): number of input-target state pairs in the QPNN training set, defaults to 0 if none provided</span>
<span class="sd">        psi_in (jnp_ndarray): $K\\times N$ array containing the $K$ input states in the QPNN training set, resolved in</span>
<span class="sd">            the $N$-dimensional second quantization Fock basis, defaults to an empty array if none provided</span>
<span class="sd">        psi_targ (jnp_ndarray): $K\\times N$ array containing the $K$ target states in the QPNN training set, resolved</span>
<span class="sd">            in the $N$-dimensional second quantization Fock basis, defaults to an empty array if none provided</span>
<span class="sd">        comp_indices (jnp_ndarray): $2^n$-length array whose elements are the indices of the second quantization Fock</span>
<span class="sd">            basis where dual-rail encoded computational basis states lie</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">L</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">varphi</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span>
        <span class="n">ell_mzi</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
        <span class="n">ell_ps</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
        <span class="n">t_dc</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
        <span class="n">training_set</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialization of an Imperfect QPNN instance.</span>

<span class="sd">        Each piece of the QPNN architecture is instantiated and stored as an attribute alongside relevant parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">            n: number of photons, $n$</span>
<span class="sd">            m: number of optical modes, $m$</span>
<span class="sd">            L: number of layers, $L$</span>
<span class="sd">            varphi: effective nonlinear phase shift, $\\varphi$</span>
<span class="sd">            ell_mzi: nominal loss for a Mach-Zehnder interferometer in dB, where the first (second) element is the mean</span>
<span class="sd">                (standard deviation) of a normal distribution from which those for each individual interferometer is</span>
<span class="sd">                selected</span>
<span class="sd">            ell_ps: nominal loss for a phase shifter in dB, where the first (second) element is the mean (standard</span>
<span class="sd">                deviation) of a normal distribution from which those for each individual output phase shifter is</span>
<span class="sd">                selected</span>
<span class="sd">            t_dc: directional coupler splitting ratios (T:R) as decimal values, where the first (second) element is the</span>
<span class="sd">                mean (standard deviation) of a normal distribution from which those for each individual nominally 50:50</span>
<span class="sd">                coupler is selected</span>
<span class="sd">            training_set: a tuple including two $K\\times N$ arrays, the first of which contains $K$ input states</span>
<span class="sd">                resolved in the second quantization Fock basis, the second of which contains the corresponding target</span>
<span class="sd">                states</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>

        <span class="c1"># instantiate L Clements meshes, with losses and routing errors, for encoding the linear layers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ell_mzi</span> <span class="o">=</span> <span class="n">ell_mzi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ell_ps</span> <span class="o">=</span> <span class="n">ell_ps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_dc</span> <span class="o">=</span> <span class="n">t_dc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">Mesh</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imperfections</span> <span class="o">=</span> <span class="n">DEFAULT</span>

        <span class="c1"># instantiate transfomer required for the multi-photon unitary transformations of the linear layers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transformer</span> <span class="o">=</span> <span class="n">SecqTransformer</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

        <span class="c1"># store the provided effective nonlinear phase shift, construct the corresponding nonlinear Kerr-like unitary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">varphi</span> <span class="o">=</span> <span class="n">varphi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nl</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">build_kerr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">varphi</span><span class="p">))</span>

        <span class="c1"># prepare the training set attributes whether one was provided or not</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">training_set</span> <span class="o">=</span> <span class="n">training_set</span> <span class="k">if</span> <span class="n">training_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(()),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(()))</span>

        <span class="c1"># compute overhead for conditional fidelity and logical rate calculations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comp_indices</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">comp_indices_from_secq</span><span class="p">(</span><span class="n">build_secq_basis</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)))</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">training_set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np_ndarray</span><span class="p">,</span> <span class="n">np_ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Training set of the QPNN.</span>

<span class="sd">        Returns:</span>
<span class="sd">            psi_in: $K\\times N$ array containing the $K$ input states resolved in the second quantization Fock basis</span>
<span class="sd">            psi_targ: $K\\times N$ array containing the $K$ target states resolved in the second quantization Fock basis</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi_in</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi_targ</span><span class="p">)</span>

    <span class="nd">@training_set</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">training_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tset</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Training set of the QPNN.</span>

<span class="sd">        Args:</span>
<span class="sd">            tset: a tuple including two $K\\times N$ arrays, the first of which contains $K$ input states resolved in</span>
<span class="sd">                the second quantization Fock basis, the second of which contains the corresponding target states</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psi_in</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">tset</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psi_targ</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">tset</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi_in</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi_in</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">imperfections</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np_ndarray</span><span class="p">,</span> <span class="n">np_ndarray</span><span class="p">,</span> <span class="n">np_ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Component-level imperfection values for each interferometer mesh in the QPNN.</span>

<span class="sd">        Realistic MZI meshes are modelled by allowing each individual interferometer to suffer unique imperfections,</span>
<span class="sd">        resulting in unbalanced, photon-path-dependent errors. The transmittance of each directional coupler is</span>
<span class="sd">        randomly selected from a normal distribution with a mean and a standard deviation as defined by attribute</span>
<span class="sd">        `t_dc`. Similarly, the photon losses introduced by each MZI and each output phase shifter in each mesh are</span>
<span class="sd">        selected from normal distributions as well, with means and standard deviations defined by attributes</span>
<span class="sd">        `ell_mzi` and `ell_ps`, respectively. The transmittance attribute is a decimal value between 0 and 1 (e.g.</span>
<span class="sd">        0.5 corresponds to 50% transmission). Conversely, the loss attributes are provided as a positive dB value,</span>
<span class="sd">        and thus must be converted to a decimal value between 0 and 1 that defines the fraction of light lost. For</span>
<span class="sd">        some positive-valued dB loss $\\ell_\\mathrm{dB}$, this fraction is given by</span>

<span class="sd">        $$ \\ell = 1 - 10^{-\\ell_\\mathrm{dB}/10}. $$</span>

<span class="sd">        From the standard deviation of the dB loss $\\sigma_\\mathrm{dB}$, the standard deviation of the fractional</span>
<span class="sd">        loss is given by</span>

<span class="sd">        $$ \\sigma = \\frac{1}{10}\\sigma_\\mathrm{dB}\\ln{(10)}\\cdot 10^{-\\ell_\\mathrm{dB}/10}. $$</span>

<span class="sd">        When setting this property, you can provide a tuple with elements including arrays of the MZI losses,</span>
<span class="sd">        phase shifter losses, and directional coupler transmissivities, respectively (all as decimal values).</span>
<span class="sd">        Alternatively, you can pass `quotonic.qpnn.DEFAULT = None` to instruct the function to sample imperfection</span>
<span class="sd">        values from the distributions defined by the internal attributes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ells_mzi: $L\\times m\\times m$ array containing the fractinal loss per arm of each of the $L$</span>
<span class="sd">                interferometer meshes, for each column of MZIs respectively</span>
<span class="sd">            ells_ps: $L\\times m$ array containing the fractional loss for each of the output phase shifters</span>
<span class="sd">                in each of the $L$ interferometer meshes</span>
<span class="sd">            ts_dc: $L\\times 2\\times m(m-1)/2$ array containing the splitting ratio (T:R) of each directional</span>
<span class="sd">                coupler in each of the $L$ interferometer meshes, organized such that each column corresponds to one</span>
<span class="sd">                MZI, the top row being the first directional coupler and the bottom being the second, where the MZIs</span>
<span class="sd">                are ordered from top to bottom followed by left to right across each mesh</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ells_mzi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">ells_ps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">ts_dc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
            <span class="n">ells_mzi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ell_mzi</span>
            <span class="n">ells_ps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ell_ps</span>
            <span class="n">ts_dc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">t_dc</span>
        <span class="k">return</span> <span class="n">ells_mzi</span><span class="p">,</span> <span class="n">ells_ps</span><span class="p">,</span> <span class="n">ts_dc</span>

    <span class="nd">@imperfections</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">imperfections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imp</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Component-level imperfection values for each interferometer mesh in the QPNN.</span>

<span class="sd">        Args:</span>
<span class="sd">            imp: Tuple of arrays, the first of which is an $L\\times m\\times m$ array containing the</span>
<span class="sd">                percentage loss per arm of each of the $L$ interferometer meshes, for each column of MZIs</span>
<span class="sd">                respectively; the second of which is an $L\\times m$ array containing the percentage loss for each of</span>
<span class="sd">                the output phase shifters in each of the $L$ interferometer meshes; the third of which is an</span>
<span class="sd">                $L\\times 2\\times m(m-1)/2$ array containing the splitting ratio (T:R) of each directional coupler</span>
<span class="sd">                in each of the $L$ interferometer meshes, organized such that each column corresponds to one MZI,</span>
<span class="sd">                the top row being the first directional coupler and the bottom being the second, where the MZIs are</span>
<span class="sd">                ordered from top to bottom followed by left to right across each mesh; if None, then this function</span>
<span class="sd">                will use the nominal imperfection attributes to generate the component-level imperfection values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">imp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># for each layer, compute and apply new loss and splitting ratio values from their respective distributions</span>
            <span class="n">ells_mzi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">ells_ps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">ts_dc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
                <span class="n">ells_mzi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span>
                    <span class="mf">1.0</span> <span class="o">-</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ell_mzi</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ell_mzi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ell_mzi</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">))</span>
                <span class="n">ells_ps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span>
                    <span class="mf">1.0</span> <span class="o">-</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ell_ps</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ell_ps</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ell_ps</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">ts_dc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_dc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_dc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ells_mzi</span><span class="p">,</span> <span class="n">ells_ps</span><span class="p">,</span> <span class="n">ts_dc</span> <span class="o">=</span> <span class="n">imp</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meshes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ell_mzi</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ells_mzi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meshes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ell_ps</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ells_ps</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meshes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">t_dc</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ts_dc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp_ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build a matrix representation of the QPNN from all its layers and components.</span>

<span class="sd">        This method calculates the system function of the QPNN as introduced at the top of this module.</span>

<span class="sd">        Args:</span>
<span class="sd">            phi: $L\\times m(m-1)/2$ phase shifts, $\\phi$, where the ith row contains those for each MZI in the</span>
<span class="sd">                ith layer</span>
<span class="sd">            theta: $L\\times m(m-1)/2$ phase shifts, $\\theta$, where the ith row contains those for each MZI in the</span>
<span class="sd">                ith layer</span>
<span class="sd">            delta: $L\\times m$ phase shifts, $\\delta$, where the ith row contains those for each mode at the output</span>
<span class="sd">                of the mesh in the ith layer</span>

<span class="sd">        Returns:</span>
<span class="sd">            S: $N\\times N$ array, the matrix representation of the QPNN resolved in the second quantization Fock basis</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># encode the single-photon unitary matrices for each linear layer in the Clements configuration</span>
        <span class="n">single_photon_Us</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meshes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span>
        <span class="p">)</span>

        <span class="c1"># perform the multi-photon unitary transformations for each linear layer</span>
        <span class="n">multi_photon_Us</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">)(</span><span class="n">single_photon_Us</span><span class="p">)</span>

        <span class="c1"># for each linear layer up to the last one, multiply the nonlinear unitary and multi-photon unitary together</span>
        <span class="n">layers</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">PhiU</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nl</span> <span class="o">@</span> <span class="n">PhiU</span><span class="p">)(</span><span class="n">multi_photon_Us</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

        <span class="c1"># stack the layers together, including the final linear layer</span>
        <span class="n">layers</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">layers</span><span class="p">,</span> <span class="n">multi_photon_Us</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))))</span>

        <span class="c1"># multiply all the layers together</span>
        <span class="n">S</span><span class="p">:</span> <span class="n">jnp_ndarray</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">matmul</span><span class="p">,</span> <span class="n">layers</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">S</span>

    <span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calc_unc_fidelity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DTypeLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the unconditional fidelity of the QPNN.</span>

<span class="sd">        This method calculates the unconditional fidelity of the QPNN as introduced at the top of this module. It</span>
<span class="sd">        relies on a training set and will thus throw an error if one has not been provided.</span>

<span class="sd">        Args:</span>
<span class="sd">            phi: $L\\times m(m-1)/2$ phase shifts, $\\phi$, where the ith row contains those for each MZI in the ith</span>
<span class="sd">                layer</span>
<span class="sd">            theta: $L\\times m(m-1)/2$ phase shifts, $\\theta$, where the ith row contains those for each MZI in the ith</span>
<span class="sd">                layer</span>
<span class="sd">            delta: $L\\times m$ phase shifts, $\\delta$, where the ith row contains those for each mode at the output</span>
<span class="sd">                of the mesh in the ith layer</span>

<span class="sd">        Returns:</span>
<span class="sd">            Func: unconditional fidelity of the QPNN</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check that a training set has been provided</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;No training set was provided for the QPNN.&quot;</span>

        <span class="c1"># construct the QPNN system function</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>

        <span class="c1"># apply the QPNN to the input states to produce the output states</span>
        <span class="n">psi_out</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psi</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">psi</span><span class="p">))(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi_in</span><span class="p">)</span>

        <span class="c1"># compute the unconditional fidelity by first computing it for all K input-target pairs, then averaging</span>
        <span class="n">Fus</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psit</span><span class="p">,</span> <span class="n">psio</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">psit</span><span class="p">),</span> <span class="n">psio</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi_targ</span><span class="p">,</span> <span class="n">psi_out</span><span class="p">)</span>
        <span class="n">Fu</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Fus</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Fu</span>

    <span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calc_performance_measures</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">DTypeLike</span><span class="p">,</span> <span class="n">DTypeLike</span><span class="p">,</span> <span class="n">DTypeLike</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the unconditional fidelity, conditional fidelity, and logical rate of the QPNN.</span>

<span class="sd">        This method calculates the unconditional fidelity, conditional fidelity, and logical rate of the QPNN as</span>
<span class="sd">        introduced at the top of this module. It relies on a training set and will thus throw an error if one has not</span>
<span class="sd">        been provided.</span>

<span class="sd">        Args:</span>
<span class="sd">            phi: $L\\times m(m-1)/2$ phase shifts, $\\phi$, where the ith row contains those for each MZI in the</span>
<span class="sd">                ith layer</span>
<span class="sd">            theta: $L\\times m(m-1)/2$ phase shifts, $\\theta$, where the ith row contains those for each MZI in</span>
<span class="sd">                the ith layer</span>
<span class="sd">            delta: $L\\times m$ phase shifts, $\\delta$, where the ith row contains those for each mode at the output</span>
<span class="sd">                of the mesh in the ith layer</span>

<span class="sd">        Returns:</span>
<span class="sd">            Func: unconditional fidelity $\\mathcal{F}^{(\\mathrm{unc})} of the QPNN</span>
<span class="sd">            Fcon: conditinal fidelity $\\mathcal{F}^{(\\mathrm{con})} of the QPNN</span>
<span class="sd">            Pcb: logical rate $\\mathcal{P}^{(\\mathrm{cb})} of the QPNN</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check that a training set has been provided</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;No training set was provided for the QPNN.&quot;</span>

        <span class="c1"># construct the QPNN system function</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>

        <span class="c1"># apply the QPNN to the input states to produce the output states</span>
        <span class="n">psi_out</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psi</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">psi</span><span class="p">))(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi_in</span><span class="p">)</span>

        <span class="c1"># compute the unconditional fidelity by first computing it for all K input-target pairs, then averaging</span>
        <span class="n">Fus</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psit</span><span class="p">,</span> <span class="n">psio</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">psit</span><span class="p">),</span> <span class="n">psio</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi_targ</span><span class="p">,</span> <span class="n">psi_out</span><span class="p">)</span>
        <span class="n">Fu</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Fus</span><span class="p">)</span>

        <span class="c1"># compute the logical rate by first computing it for all K input-target pairs, then averaging</span>
        <span class="n">rates</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psi</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">psi</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">comp_indices</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))(</span><span class="n">psi_out</span><span class="p">)</span>
        <span class="n">rate</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">rates</span><span class="p">)</span>

        <span class="c1"># compute the conditional fidelity by first computing it for all K input-target pairs, then averaging</span>
        <span class="n">Fcs</span> <span class="o">=</span> <span class="n">Fus</span> <span class="o">/</span> <span class="n">rates</span>
        <span class="n">Fc</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Fcs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Fu</span><span class="p">,</span> <span class="n">Fc</span><span class="p">,</span> <span class="n">rate</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-function">


<h3 id="quotonic.qpnn.ImperfectQPNN.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">varphi</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">ell_mzi</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">ell_ps</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">t_dc</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">training_set</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

<a href="#quotonic.qpnn.ImperfectQPNN.__init__" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Initialization of an Imperfect QPNN instance.</p>
<p>Each piece of the QPNN architecture is instantiated and stored as an attribute alongside relevant parameters.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>n</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of photons, <span class="arithmatex">\(n\)</span></p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>m</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of optical modes, <span class="arithmatex">\(m\)</span></p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>L</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of layers, <span class="arithmatex">\(L\)</span></p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>varphi</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>effective nonlinear phase shift, <span class="arithmatex">\(\varphi\)</span></p>
              </div>
            </td>
            <td>
                  <code><span title="numpy.pi">pi</span></code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>ell_mzi</code>
            </td>
            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>nominal loss for a Mach-Zehnder interferometer in dB, where the first (second) element is the mean
(standard deviation) of a normal distribution from which those for each individual interferometer is
selected</p>
              </div>
            </td>
            <td>
                  <code>(0.0, 0.0)</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>ell_ps</code>
            </td>
            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>nominal loss for a phase shifter in dB, where the first (second) element is the mean (standard
deviation) of a normal distribution from which those for each individual output phase shifter is
selected</p>
              </div>
            </td>
            <td>
                  <code>(0.0, 0.0)</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>t_dc</code>
            </td>
            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>directional coupler splitting ratios (T:R) as decimal values, where the first (second) element is the
mean (standard deviation) of a normal distribution from which those for each individual nominally 50:50
coupler is selected</p>
              </div>
            </td>
            <td>
                  <code>(0.5, 0.0)</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>training_set</code>
            </td>
            <td>
                  <code><span title="tuple">tuple</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>a tuple including two <span class="arithmatex">\(K\times N\)</span> arrays, the first of which contains <span class="arithmatex">\(K\)</span> input states
resolved in the second quantization Fock basis, the second of which contains the corresponding target
states</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/qpnn.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">L</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">varphi</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span>
    <span class="n">ell_mzi</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
    <span class="n">ell_ps</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
    <span class="n">t_dc</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
    <span class="n">training_set</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialization of an Imperfect QPNN instance.</span>

<span class="sd">    Each piece of the QPNN architecture is instantiated and stored as an attribute alongside relevant parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        n: number of photons, $n$</span>
<span class="sd">        m: number of optical modes, $m$</span>
<span class="sd">        L: number of layers, $L$</span>
<span class="sd">        varphi: effective nonlinear phase shift, $\\varphi$</span>
<span class="sd">        ell_mzi: nominal loss for a Mach-Zehnder interferometer in dB, where the first (second) element is the mean</span>
<span class="sd">            (standard deviation) of a normal distribution from which those for each individual interferometer is</span>
<span class="sd">            selected</span>
<span class="sd">        ell_ps: nominal loss for a phase shifter in dB, where the first (second) element is the mean (standard</span>
<span class="sd">            deviation) of a normal distribution from which those for each individual output phase shifter is</span>
<span class="sd">            selected</span>
<span class="sd">        t_dc: directional coupler splitting ratios (T:R) as decimal values, where the first (second) element is the</span>
<span class="sd">            mean (standard deviation) of a normal distribution from which those for each individual nominally 50:50</span>
<span class="sd">            coupler is selected</span>
<span class="sd">        training_set: a tuple including two $K\\times N$ arrays, the first of which contains $K$ input states</span>
<span class="sd">            resolved in the second quantization Fock basis, the second of which contains the corresponding target</span>
<span class="sd">            states</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>

    <span class="c1"># instantiate L Clements meshes, with losses and routing errors, for encoding the linear layers</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ell_mzi</span> <span class="o">=</span> <span class="n">ell_mzi</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ell_ps</span> <span class="o">=</span> <span class="n">ell_ps</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">t_dc</span> <span class="o">=</span> <span class="n">t_dc</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">meshes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">Mesh</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">)])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">imperfections</span> <span class="o">=</span> <span class="n">DEFAULT</span>

    <span class="c1"># instantiate transfomer required for the multi-photon unitary transformations of the linear layers</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">transformer</span> <span class="o">=</span> <span class="n">SecqTransformer</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="c1"># store the provided effective nonlinear phase shift, construct the corresponding nonlinear Kerr-like unitary</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">varphi</span> <span class="o">=</span> <span class="n">varphi</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nl</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">build_kerr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">varphi</span><span class="p">))</span>

    <span class="c1"># prepare the training set attributes whether one was provided or not</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">training_set</span> <span class="o">=</span> <span class="n">training_set</span> <span class="k">if</span> <span class="n">training_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(()),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(()))</span>

    <span class="c1"># compute overhead for conditional fidelity and logical rate calculations</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">comp_indices</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">comp_indices_from_secq</span><span class="p">(</span><span class="n">build_secq_basis</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>






<div class="doc doc-object doc-attribute">



<h3 id="quotonic.qpnn.ImperfectQPNN.training_set" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">training_set</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
      <small class="doc doc-label doc-label-writable"><code>writable</code></small>
  </span>

<a href="#quotonic.qpnn.ImperfectQPNN.training_set" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Training set of the QPNN.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>psi_in</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="np_ndarray = np.ndarray

  
      module-attribute
   (quotonic.types.np_ndarray)" href="../types/#quotonic.types.np_ndarray">np_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(K\times N\)</span> array containing the <span class="arithmatex">\(K\)</span> input states resolved in the second quantization Fock basis</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>psi_targ</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="np_ndarray = np.ndarray

  
      module-attribute
   (quotonic.types.np_ndarray)" href="../types/#quotonic.types.np_ndarray">np_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(K\times N\)</span> array containing the <span class="arithmatex">\(K\)</span> target states resolved in the second quantization Fock basis</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

    </div>

</div>






<div class="doc doc-object doc-attribute">



<h3 id="quotonic.qpnn.ImperfectQPNN.imperfections" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">imperfections</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
      <small class="doc doc-label doc-label-writable"><code>writable</code></small>
  </span>

<a href="#quotonic.qpnn.ImperfectQPNN.imperfections" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Component-level imperfection values for each interferometer mesh in the QPNN.</p>
<p>Realistic MZI meshes are modelled by allowing each individual interferometer to suffer unique imperfections,
resulting in unbalanced, photon-path-dependent errors. The transmittance of each directional coupler is
randomly selected from a normal distribution with a mean and a standard deviation as defined by attribute
<code>t_dc</code>. Similarly, the photon losses introduced by each MZI and each output phase shifter in each mesh are
selected from normal distributions as well, with means and standard deviations defined by attributes
<code>ell_mzi</code> and <code>ell_ps</code>, respectively. The transmittance attribute is a decimal value between 0 and 1 (e.g.
0.5 corresponds to 50% transmission). Conversely, the loss attributes are provided as a positive dB value,
and thus must be converted to a decimal value between 0 and 1 that defines the fraction of light lost. For
some positive-valued dB loss <span class="arithmatex">\(\ell_\mathrm{dB}\)</span>, this fraction is given by</p>
<div class="arithmatex">\[ \ell = 1 - 10^{-\ell_\mathrm{dB}/10}. \]</div>
<p>From the standard deviation of the dB loss <span class="arithmatex">\(\sigma_\mathrm{dB}\)</span>, the standard deviation of the fractional
loss is given by</p>
<div class="arithmatex">\[ \sigma = \frac{1}{10}\sigma_\mathrm{dB}\ln{(10)}\cdot 10^{-\ell_\mathrm{dB}/10}. \]</div>
<p>When setting this property, you can provide a tuple with elements including arrays of the MZI losses,
phase shifter losses, and directional coupler transmissivities, respectively (all as decimal values).
Alternatively, you can pass <code>quotonic.qpnn.DEFAULT = None</code> to instruct the function to sample imperfection
values from the distributions defined by the internal attributes.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>ells_mzi</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="np_ndarray = np.ndarray

  
      module-attribute
   (quotonic.types.np_ndarray)" href="../types/#quotonic.types.np_ndarray">np_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m\times m\)</span> array containing the fractinal loss per arm of each of the <span class="arithmatex">\(L\)</span>
interferometer meshes, for each column of MZIs respectively</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>ells_ps</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="np_ndarray = np.ndarray

  
      module-attribute
   (quotonic.types.np_ndarray)" href="../types/#quotonic.types.np_ndarray">np_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m\)</span> array containing the fractional loss for each of the output phase shifters
in each of the <span class="arithmatex">\(L\)</span> interferometer meshes</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>ts_dc</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="np_ndarray = np.ndarray

  
      module-attribute
   (quotonic.types.np_ndarray)" href="../types/#quotonic.types.np_ndarray">np_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times 2\times m(m-1)/2\)</span> array containing the splitting ratio (T:R) of each directional
coupler in each of the <span class="arithmatex">\(L\)</span> interferometer meshes, organized such that each column corresponds to one
MZI, the top row being the first directional coupler and the bottom being the second, where the MZIs
are ordered from top to bottom followed by left to right across each mesh</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

    </div>

</div>






<div class="doc doc-object doc-function">


<h3 id="quotonic.qpnn.ImperfectQPNN.build" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">build</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span></code>

<a href="#quotonic.qpnn.ImperfectQPNN.build" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Build a matrix representation of the QPNN from all its layers and components.</p>
<p>This method calculates the system function of the QPNN as introduced at the top of this module.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>phi</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> phase shifts, <span class="arithmatex">\(\phi\)</span>, where the ith row contains those for each MZI in the
ith layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>theta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> phase shifts, <span class="arithmatex">\(\theta\)</span>, where the ith row contains those for each MZI in the
ith layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>delta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m\)</span> phase shifts, <span class="arithmatex">\(\delta\)</span>, where the ith row contains those for each mode at the output
of the mesh in the ith layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>S</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(N\times N\)</span> array, the matrix representation of the QPNN resolved in the second quantization Fock basis</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/qpnn.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
<span class="k">def</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp_ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Build a matrix representation of the QPNN from all its layers and components.</span>

<span class="sd">    This method calculates the system function of the QPNN as introduced at the top of this module.</span>

<span class="sd">    Args:</span>
<span class="sd">        phi: $L\\times m(m-1)/2$ phase shifts, $\\phi$, where the ith row contains those for each MZI in the</span>
<span class="sd">            ith layer</span>
<span class="sd">        theta: $L\\times m(m-1)/2$ phase shifts, $\\theta$, where the ith row contains those for each MZI in the</span>
<span class="sd">            ith layer</span>
<span class="sd">        delta: $L\\times m$ phase shifts, $\\delta$, where the ith row contains those for each mode at the output</span>
<span class="sd">            of the mesh in the ith layer</span>

<span class="sd">    Returns:</span>
<span class="sd">        S: $N\\times N$ array, the matrix representation of the QPNN resolved in the second quantization Fock basis</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># encode the single-photon unitary matrices for each linear layer in the Clements configuration</span>
    <span class="n">single_photon_Us</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meshes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span>
    <span class="p">)</span>

    <span class="c1"># perform the multi-photon unitary transformations for each linear layer</span>
    <span class="n">multi_photon_Us</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">)(</span><span class="n">single_photon_Us</span><span class="p">)</span>

    <span class="c1"># for each linear layer up to the last one, multiply the nonlinear unitary and multi-photon unitary together</span>
    <span class="n">layers</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">PhiU</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">nl</span> <span class="o">@</span> <span class="n">PhiU</span><span class="p">)(</span><span class="n">multi_photon_Us</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

    <span class="c1"># stack the layers together, including the final linear layer</span>
    <span class="n">layers</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">layers</span><span class="p">,</span> <span class="n">multi_photon_Us</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">))))</span>

    <span class="c1"># multiply all the layers together</span>
    <span class="n">S</span><span class="p">:</span> <span class="n">jnp_ndarray</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">matmul</span><span class="p">,</span> <span class="n">layers</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">S</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>






<div class="doc doc-object doc-function">


<h3 id="quotonic.qpnn.ImperfectQPNN.calc_unc_fidelity" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">calc_unc_fidelity</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span></code>

<a href="#quotonic.qpnn.ImperfectQPNN.calc_unc_fidelity" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Calculate the unconditional fidelity of the QPNN.</p>
<p>This method calculates the unconditional fidelity of the QPNN as introduced at the top of this module. It
relies on a training set and will thus throw an error if one has not been provided.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>phi</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> phase shifts, <span class="arithmatex">\(\phi\)</span>, where the ith row contains those for each MZI in the ith
layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>theta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> phase shifts, <span class="arithmatex">\(\theta\)</span>, where the ith row contains those for each MZI in the ith
layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>delta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m\)</span> phase shifts, <span class="arithmatex">\(\delta\)</span>, where the ith row contains those for each mode at the output
of the mesh in the ith layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>Func</code></td>            <td>
                  <code><span title="jax.typing.DTypeLike">DTypeLike</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>unconditional fidelity of the QPNN</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/qpnn.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
<span class="k">def</span><span class="w"> </span><span class="nf">calc_unc_fidelity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DTypeLike</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the unconditional fidelity of the QPNN.</span>

<span class="sd">    This method calculates the unconditional fidelity of the QPNN as introduced at the top of this module. It</span>
<span class="sd">    relies on a training set and will thus throw an error if one has not been provided.</span>

<span class="sd">    Args:</span>
<span class="sd">        phi: $L\\times m(m-1)/2$ phase shifts, $\\phi$, where the ith row contains those for each MZI in the ith</span>
<span class="sd">            layer</span>
<span class="sd">        theta: $L\\times m(m-1)/2$ phase shifts, $\\theta$, where the ith row contains those for each MZI in the ith</span>
<span class="sd">            layer</span>
<span class="sd">        delta: $L\\times m$ phase shifts, $\\delta$, where the ith row contains those for each mode at the output</span>
<span class="sd">            of the mesh in the ith layer</span>

<span class="sd">    Returns:</span>
<span class="sd">        Func: unconditional fidelity of the QPNN</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check that a training set has been provided</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;No training set was provided for the QPNN.&quot;</span>

    <span class="c1"># construct the QPNN system function</span>
    <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>

    <span class="c1"># apply the QPNN to the input states to produce the output states</span>
    <span class="n">psi_out</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psi</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">psi</span><span class="p">))(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi_in</span><span class="p">)</span>

    <span class="c1"># compute the unconditional fidelity by first computing it for all K input-target pairs, then averaging</span>
    <span class="n">Fus</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psit</span><span class="p">,</span> <span class="n">psio</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">psit</span><span class="p">),</span> <span class="n">psio</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi_targ</span><span class="p">,</span> <span class="n">psi_out</span><span class="p">)</span>
    <span class="n">Fu</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Fus</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Fu</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>






<div class="doc doc-object doc-function">


<h3 id="quotonic.qpnn.ImperfectQPNN.calc_performance_measures" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">calc_performance_measures</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span></code>

<a href="#quotonic.qpnn.ImperfectQPNN.calc_performance_measures" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Calculate the unconditional fidelity, conditional fidelity, and logical rate of the QPNN.</p>
<p>This method calculates the unconditional fidelity, conditional fidelity, and logical rate of the QPNN as
introduced at the top of this module. It relies on a training set and will thus throw an error if one has not
been provided.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>phi</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> phase shifts, <span class="arithmatex">\(\phi\)</span>, where the ith row contains those for each MZI in the
ith layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>theta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> phase shifts, <span class="arithmatex">\(\theta\)</span>, where the ith row contains those for each MZI in
the ith layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>delta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m\)</span> phase shifts, <span class="arithmatex">\(\delta\)</span>, where the ith row contains those for each mode at the output
of the mesh in the ith layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>Func</code></td>            <td>
                  <code><span title="jax.typing.DTypeLike">DTypeLike</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>unconditional fidelity $\mathcal{F}^{(\mathrm{unc})} of the QPNN</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>Fcon</code></td>            <td>
                  <code><span title="jax.typing.DTypeLike">DTypeLike</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>conditinal fidelity $\mathcal{F}^{(\mathrm{con})} of the QPNN</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>Pcb</code></td>            <td>
                  <code><span title="jax.typing.DTypeLike">DTypeLike</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>logical rate $\mathcal{P}^{(\mathrm{cb})} of the QPNN</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/qpnn.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
<span class="k">def</span><span class="w"> </span><span class="nf">calc_performance_measures</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">DTypeLike</span><span class="p">,</span> <span class="n">DTypeLike</span><span class="p">,</span> <span class="n">DTypeLike</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the unconditional fidelity, conditional fidelity, and logical rate of the QPNN.</span>

<span class="sd">    This method calculates the unconditional fidelity, conditional fidelity, and logical rate of the QPNN as</span>
<span class="sd">    introduced at the top of this module. It relies on a training set and will thus throw an error if one has not</span>
<span class="sd">    been provided.</span>

<span class="sd">    Args:</span>
<span class="sd">        phi: $L\\times m(m-1)/2$ phase shifts, $\\phi$, where the ith row contains those for each MZI in the</span>
<span class="sd">            ith layer</span>
<span class="sd">        theta: $L\\times m(m-1)/2$ phase shifts, $\\theta$, where the ith row contains those for each MZI in</span>
<span class="sd">            the ith layer</span>
<span class="sd">        delta: $L\\times m$ phase shifts, $\\delta$, where the ith row contains those for each mode at the output</span>
<span class="sd">            of the mesh in the ith layer</span>

<span class="sd">    Returns:</span>
<span class="sd">        Func: unconditional fidelity $\\mathcal{F}^{(\\mathrm{unc})} of the QPNN</span>
<span class="sd">        Fcon: conditinal fidelity $\\mathcal{F}^{(\\mathrm{con})} of the QPNN</span>
<span class="sd">        Pcb: logical rate $\\mathcal{P}^{(\\mathrm{cb})} of the QPNN</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check that a training set has been provided</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;No training set was provided for the QPNN.&quot;</span>

    <span class="c1"># construct the QPNN system function</span>
    <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>

    <span class="c1"># apply the QPNN to the input states to produce the output states</span>
    <span class="n">psi_out</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psi</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">psi</span><span class="p">))(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi_in</span><span class="p">)</span>

    <span class="c1"># compute the unconditional fidelity by first computing it for all K input-target pairs, then averaging</span>
    <span class="n">Fus</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psit</span><span class="p">,</span> <span class="n">psio</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">psit</span><span class="p">),</span> <span class="n">psio</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi_targ</span><span class="p">,</span> <span class="n">psi_out</span><span class="p">)</span>
    <span class="n">Fu</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Fus</span><span class="p">)</span>

    <span class="c1"># compute the logical rate by first computing it for all K input-target pairs, then averaging</span>
    <span class="n">rates</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psi</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">psi</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">comp_indices</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))(</span><span class="n">psi_out</span><span class="p">)</span>
    <span class="n">rate</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">rates</span><span class="p">)</span>

    <span class="c1"># compute the conditional fidelity by first computing it for all K input-target pairs, then averaging</span>
    <span class="n">Fcs</span> <span class="o">=</span> <span class="n">Fus</span> <span class="o">/</span> <span class="n">rates</span>
    <span class="n">Fc</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Fcs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Fu</span><span class="p">,</span> <span class="n">Fc</span><span class="p">,</span> <span class="n">rate</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>




  </div>

    </div>

</div>






<div class="doc doc-object doc-class">



<h2 id="quotonic.qpnn.TreeQPNN" class="doc doc-heading">
            <code>TreeQPNN</code>


<a href="#quotonic.qpnn.TreeQPNN" class="headerlink" title="Permanent link">&para;</a></h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="QPNN (quotonic.qpnn.QPNN)" href="#quotonic.qpnn.QPNN">QPNN</a></code></p>


        <p>Class for experimental modelling of QPNNs based on three-level system photon subtraction/addition nonlinearities
that power a tree-type photonic cluster state generation protocol.</p>
<p>Here, we extend upon the QPNN model further, now incorporating both imperfections as well as the cavity-assisted
three-level system scattering nonlinearity introduced in <a href="https://doi.org/10.1038/s41534-025-01096-9">J. R. Basani <em>et al</em>., "Universal logical quantum
photonic neural network processor via cavity-assisted interactions", <em>npj Quantum Inf</em> <strong>11</strong>, 142 (2025)</a>. Additionally, this model is specifically designed for compatibility
with the tree-type photonic cluster state generation protocol outlined in <a href="https://doi.org/10.48550/arXiv.2505.14628">J. Ewaniuk <em>et al</em>., "Large-Scale
Tree-Type Photonic Cluster State Generation with Recurrent Quantum Photonic Neural Networks", arXiv:2505.14628
[quant-ph]</a>. As in <code>IdealQPNN</code>, a provided truth table defines the
training set, however, this set is more involved than the previous models. When generating trees, the QPNN must
perform photon-number-dependent operations, responding only to the input photons without active adjustment. As a
result, there are multiple training subsets for different numbers of photons, and more specifically different
tree unit cells that must be formed.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.TreeQPNN.n">n</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of photons, <span class="arithmatex">\(n\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.TreeQPNN.m">m</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of optical modes, <span class="arithmatex">\(m\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.TreeQPNN.L">L</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of layers, <span class="arithmatex">\(L\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.TreeQPNN.b">b</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>maximum number of branches in the tree, <span class="arithmatex">\(b\equiv\max\{\vec{b}\}\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.TreeQPNN.N">N</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>dimension of the second quantization Fock basis for <span class="arithmatex">\(n\)</span> photons and <span class="arithmatex">\(m\)</span> optical modes</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.TreeQPNN.Ns">Ns</span></code></td>
            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple of <span class="arithmatex">\(b + 1\)</span> dimensions of the second quantization Fock bases for <span class="arithmatex">\(n\)</span> photons and <span class="arithmatex">\(m\)</span> optical
modes for all <span class="arithmatex">\(1 \leq n \leq b + 1\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.TreeQPNN.meshes">meshes</span></code></td>
            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple of <span class="arithmatex">\(L\)</span> objects containing methods that allow each linear layer (i.e. rectangular
Mach-Zehnder interferometer meshes) to be encoded</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.TreeQPNN.ell_mzi">ell_mzi</span></code></td>
            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>nominal loss for a Mach-Zehnder interferometer in dB, where the first (second) element is the
mean (standard deviation) of a normal distribution from which those for each individual interferometer is
selected</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.TreeQPNN.ell_ps">ell_ps</span></code></td>
            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>nominal loss for a phase shifter in dB, where the first (second) element is the mean (standard
deviation) of a normal distribution from which those for each individual output phase shifter is selected</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.TreeQPNN.t_dc">t_dc</span></code></td>
            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>directional coupler splitting ratios (T:R) as decimal values, where the first (second) element is
the mean (standard deviation) of a normal distribution from which those for each individual nominally 50:50
coupler is selected</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.TreeQPNN.transformers">transformers</span></code></td>
            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple of <span class="arithmatex">\(b + 1\)</span> objects containing methods that compute multi-photon unitary
transformations of the linear layers for all <span class="arithmatex">\(1 \leq n \leq b + 1\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.TreeQPNN.varphi">varphi</span></code></td>
            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple of the phase shifts applied to the subtracted photon, followed by that applied to the
remaining photons, for the 3LS photon <span class="arithmatex">\(\mp\)</span> nonlinearity, in <span class="arithmatex">\(\text{rad}\)</span>, <span class="arithmatex">\((\varphi_1, \varphi2)\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.TreeQPNN.nls">nls</span></code></td>
            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple of <span class="arithmatex">\(b + 1\)</span> <span class="arithmatex">\(N\times N\)</span> arrays, the <span class="arithmatex">\(b + 1\)</span> matrix representations of a set of single-site
3LS photon <span class="arithmatex">\(\mp\)</span> nonlinearities resolved in the Fock bases for all <span class="arithmatex">\(1 \leq n \leq b + 1\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.TreeQPNN.K">K</span></code></td>
            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>arrays containing the numbers of input-target state pairs in the QPNN training set for each
<span class="arithmatex">\(1 \leq n \leq b + 1\)</span>, per unit cell operation, defaults to a tuple of zeros if none provided</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.TreeQPNN.psi_in">psi_in</span></code></td>
            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>arrays containing the input states of the QPNN training set, resolved in the <span class="arithmatex">\(2^n\)</span>-dimensional
computational bases, for each <span class="arithmatex">\(1 \leq n \leq b + 1\)</span>, defaults to a tuple of empty arrays if none provided</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.TreeQPNN.psi_targ">psi_targ</span></code></td>
            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>arrays containing the target states of the QPNN training set, resolved in the
<span class="arithmatex">\(2^n\)</span>-dimensional computational bases, for each <span class="arithmatex">\(1 \leq n \leq b + 1\)</span>, defaults to a tuple of empty
arrays if none provided</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.qpnn.TreeQPNN.comp_indices">comp_indices</span></code></td>
            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>arrays containing the indices of each second quantization Fock basis, for each
<span class="arithmatex">\(1 \leq n \leq b + 1\)</span>, that correspond to each possible unit cell operation, defaults to a tuple of empty
arrays if none provided</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>








              <details class="quote">
                <summary>Source code in <code>src/quotonic/qpnn.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 600</span>
<span class="normal"> 601</span>
<span class="normal"> 602</span>
<span class="normal"> 603</span>
<span class="normal"> 604</span>
<span class="normal"> 605</span>
<span class="normal"> 606</span>
<span class="normal"> 607</span>
<span class="normal"> 608</span>
<span class="normal"> 609</span>
<span class="normal"> 610</span>
<span class="normal"> 611</span>
<span class="normal"> 612</span>
<span class="normal"> 613</span>
<span class="normal"> 614</span>
<span class="normal"> 615</span>
<span class="normal"> 616</span>
<span class="normal"> 617</span>
<span class="normal"> 618</span>
<span class="normal"> 619</span>
<span class="normal"> 620</span>
<span class="normal"> 621</span>
<span class="normal"> 622</span>
<span class="normal"> 623</span>
<span class="normal"> 624</span>
<span class="normal"> 625</span>
<span class="normal"> 626</span>
<span class="normal"> 627</span>
<span class="normal"> 628</span>
<span class="normal"> 629</span>
<span class="normal"> 630</span>
<span class="normal"> 631</span>
<span class="normal"> 632</span>
<span class="normal"> 633</span>
<span class="normal"> 634</span>
<span class="normal"> 635</span>
<span class="normal"> 636</span>
<span class="normal"> 637</span>
<span class="normal"> 638</span>
<span class="normal"> 639</span>
<span class="normal"> 640</span>
<span class="normal"> 641</span>
<span class="normal"> 642</span>
<span class="normal"> 643</span>
<span class="normal"> 644</span>
<span class="normal"> 645</span>
<span class="normal"> 646</span>
<span class="normal"> 647</span>
<span class="normal"> 648</span>
<span class="normal"> 649</span>
<span class="normal"> 650</span>
<span class="normal"> 651</span>
<span class="normal"> 652</span>
<span class="normal"> 653</span>
<span class="normal"> 654</span>
<span class="normal"> 655</span>
<span class="normal"> 656</span>
<span class="normal"> 657</span>
<span class="normal"> 658</span>
<span class="normal"> 659</span>
<span class="normal"> 660</span>
<span class="normal"> 661</span>
<span class="normal"> 662</span>
<span class="normal"> 663</span>
<span class="normal"> 664</span>
<span class="normal"> 665</span>
<span class="normal"> 666</span>
<span class="normal"> 667</span>
<span class="normal"> 668</span>
<span class="normal"> 669</span>
<span class="normal"> 670</span>
<span class="normal"> 671</span>
<span class="normal"> 672</span>
<span class="normal"> 673</span>
<span class="normal"> 674</span>
<span class="normal"> 675</span>
<span class="normal"> 676</span>
<span class="normal"> 677</span>
<span class="normal"> 678</span>
<span class="normal"> 679</span>
<span class="normal"> 680</span>
<span class="normal"> 681</span>
<span class="normal"> 682</span>
<span class="normal"> 683</span>
<span class="normal"> 684</span>
<span class="normal"> 685</span>
<span class="normal"> 686</span>
<span class="normal"> 687</span>
<span class="normal"> 688</span>
<span class="normal"> 689</span>
<span class="normal"> 690</span>
<span class="normal"> 691</span>
<span class="normal"> 692</span>
<span class="normal"> 693</span>
<span class="normal"> 694</span>
<span class="normal"> 695</span>
<span class="normal"> 696</span>
<span class="normal"> 697</span>
<span class="normal"> 698</span>
<span class="normal"> 699</span>
<span class="normal"> 700</span>
<span class="normal"> 701</span>
<span class="normal"> 702</span>
<span class="normal"> 703</span>
<span class="normal"> 704</span>
<span class="normal"> 705</span>
<span class="normal"> 706</span>
<span class="normal"> 707</span>
<span class="normal"> 708</span>
<span class="normal"> 709</span>
<span class="normal"> 710</span>
<span class="normal"> 711</span>
<span class="normal"> 712</span>
<span class="normal"> 713</span>
<span class="normal"> 714</span>
<span class="normal"> 715</span>
<span class="normal"> 716</span>
<span class="normal"> 717</span>
<span class="normal"> 718</span>
<span class="normal"> 719</span>
<span class="normal"> 720</span>
<span class="normal"> 721</span>
<span class="normal"> 722</span>
<span class="normal"> 723</span>
<span class="normal"> 724</span>
<span class="normal"> 725</span>
<span class="normal"> 726</span>
<span class="normal"> 727</span>
<span class="normal"> 728</span>
<span class="normal"> 729</span>
<span class="normal"> 730</span>
<span class="normal"> 731</span>
<span class="normal"> 732</span>
<span class="normal"> 733</span>
<span class="normal"> 734</span>
<span class="normal"> 735</span>
<span class="normal"> 736</span>
<span class="normal"> 737</span>
<span class="normal"> 738</span>
<span class="normal"> 739</span>
<span class="normal"> 740</span>
<span class="normal"> 741</span>
<span class="normal"> 742</span>
<span class="normal"> 743</span>
<span class="normal"> 744</span>
<span class="normal"> 745</span>
<span class="normal"> 746</span>
<span class="normal"> 747</span>
<span class="normal"> 748</span>
<span class="normal"> 749</span>
<span class="normal"> 750</span>
<span class="normal"> 751</span>
<span class="normal"> 752</span>
<span class="normal"> 753</span>
<span class="normal"> 754</span>
<span class="normal"> 755</span>
<span class="normal"> 756</span>
<span class="normal"> 757</span>
<span class="normal"> 758</span>
<span class="normal"> 759</span>
<span class="normal"> 760</span>
<span class="normal"> 761</span>
<span class="normal"> 762</span>
<span class="normal"> 763</span>
<span class="normal"> 764</span>
<span class="normal"> 765</span>
<span class="normal"> 766</span>
<span class="normal"> 767</span>
<span class="normal"> 768</span>
<span class="normal"> 769</span>
<span class="normal"> 770</span>
<span class="normal"> 771</span>
<span class="normal"> 772</span>
<span class="normal"> 773</span>
<span class="normal"> 774</span>
<span class="normal"> 775</span>
<span class="normal"> 776</span>
<span class="normal"> 777</span>
<span class="normal"> 778</span>
<span class="normal"> 779</span>
<span class="normal"> 780</span>
<span class="normal"> 781</span>
<span class="normal"> 782</span>
<span class="normal"> 783</span>
<span class="normal"> 784</span>
<span class="normal"> 785</span>
<span class="normal"> 786</span>
<span class="normal"> 787</span>
<span class="normal"> 788</span>
<span class="normal"> 789</span>
<span class="normal"> 790</span>
<span class="normal"> 791</span>
<span class="normal"> 792</span>
<span class="normal"> 793</span>
<span class="normal"> 794</span>
<span class="normal"> 795</span>
<span class="normal"> 796</span>
<span class="normal"> 797</span>
<span class="normal"> 798</span>
<span class="normal"> 799</span>
<span class="normal"> 800</span>
<span class="normal"> 801</span>
<span class="normal"> 802</span>
<span class="normal"> 803</span>
<span class="normal"> 804</span>
<span class="normal"> 805</span>
<span class="normal"> 806</span>
<span class="normal"> 807</span>
<span class="normal"> 808</span>
<span class="normal"> 809</span>
<span class="normal"> 810</span>
<span class="normal"> 811</span>
<span class="normal"> 812</span>
<span class="normal"> 813</span>
<span class="normal"> 814</span>
<span class="normal"> 815</span>
<span class="normal"> 816</span>
<span class="normal"> 817</span>
<span class="normal"> 818</span>
<span class="normal"> 819</span>
<span class="normal"> 820</span>
<span class="normal"> 821</span>
<span class="normal"> 822</span>
<span class="normal"> 823</span>
<span class="normal"> 824</span>
<span class="normal"> 825</span>
<span class="normal"> 826</span>
<span class="normal"> 827</span>
<span class="normal"> 828</span>
<span class="normal"> 829</span>
<span class="normal"> 830</span>
<span class="normal"> 831</span>
<span class="normal"> 832</span>
<span class="normal"> 833</span>
<span class="normal"> 834</span>
<span class="normal"> 835</span>
<span class="normal"> 836</span>
<span class="normal"> 837</span>
<span class="normal"> 838</span>
<span class="normal"> 839</span>
<span class="normal"> 840</span>
<span class="normal"> 841</span>
<span class="normal"> 842</span>
<span class="normal"> 843</span>
<span class="normal"> 844</span>
<span class="normal"> 845</span>
<span class="normal"> 846</span>
<span class="normal"> 847</span>
<span class="normal"> 848</span>
<span class="normal"> 849</span>
<span class="normal"> 850</span>
<span class="normal"> 851</span>
<span class="normal"> 852</span>
<span class="normal"> 853</span>
<span class="normal"> 854</span>
<span class="normal"> 855</span>
<span class="normal"> 856</span>
<span class="normal"> 857</span>
<span class="normal"> 858</span>
<span class="normal"> 859</span>
<span class="normal"> 860</span>
<span class="normal"> 861</span>
<span class="normal"> 862</span>
<span class="normal"> 863</span>
<span class="normal"> 864</span>
<span class="normal"> 865</span>
<span class="normal"> 866</span>
<span class="normal"> 867</span>
<span class="normal"> 868</span>
<span class="normal"> 869</span>
<span class="normal"> 870</span>
<span class="normal"> 871</span>
<span class="normal"> 872</span>
<span class="normal"> 873</span>
<span class="normal"> 874</span>
<span class="normal"> 875</span>
<span class="normal"> 876</span>
<span class="normal"> 877</span>
<span class="normal"> 878</span>
<span class="normal"> 879</span>
<span class="normal"> 880</span>
<span class="normal"> 881</span>
<span class="normal"> 882</span>
<span class="normal"> 883</span>
<span class="normal"> 884</span>
<span class="normal"> 885</span>
<span class="normal"> 886</span>
<span class="normal"> 887</span>
<span class="normal"> 888</span>
<span class="normal"> 889</span>
<span class="normal"> 890</span>
<span class="normal"> 891</span>
<span class="normal"> 892</span>
<span class="normal"> 893</span>
<span class="normal"> 894</span>
<span class="normal"> 895</span>
<span class="normal"> 896</span>
<span class="normal"> 897</span>
<span class="normal"> 898</span>
<span class="normal"> 899</span>
<span class="normal"> 900</span>
<span class="normal"> 901</span>
<span class="normal"> 902</span>
<span class="normal"> 903</span>
<span class="normal"> 904</span>
<span class="normal"> 905</span>
<span class="normal"> 906</span>
<span class="normal"> 907</span>
<span class="normal"> 908</span>
<span class="normal"> 909</span>
<span class="normal"> 910</span>
<span class="normal"> 911</span>
<span class="normal"> 912</span>
<span class="normal"> 913</span>
<span class="normal"> 914</span>
<span class="normal"> 915</span>
<span class="normal"> 916</span>
<span class="normal"> 917</span>
<span class="normal"> 918</span>
<span class="normal"> 919</span>
<span class="normal"> 920</span>
<span class="normal"> 921</span>
<span class="normal"> 922</span>
<span class="normal"> 923</span>
<span class="normal"> 924</span>
<span class="normal"> 925</span>
<span class="normal"> 926</span>
<span class="normal"> 927</span>
<span class="normal"> 928</span>
<span class="normal"> 929</span>
<span class="normal"> 930</span>
<span class="normal"> 931</span>
<span class="normal"> 932</span>
<span class="normal"> 933</span>
<span class="normal"> 934</span>
<span class="normal"> 935</span>
<span class="normal"> 936</span>
<span class="normal"> 937</span>
<span class="normal"> 938</span>
<span class="normal"> 939</span>
<span class="normal"> 940</span>
<span class="normal"> 941</span>
<span class="normal"> 942</span>
<span class="normal"> 943</span>
<span class="normal"> 944</span>
<span class="normal"> 945</span>
<span class="normal"> 946</span>
<span class="normal"> 947</span>
<span class="normal"> 948</span>
<span class="normal"> 949</span>
<span class="normal"> 950</span>
<span class="normal"> 951</span>
<span class="normal"> 952</span>
<span class="normal"> 953</span>
<span class="normal"> 954</span>
<span class="normal"> 955</span>
<span class="normal"> 956</span>
<span class="normal"> 957</span>
<span class="normal"> 958</span>
<span class="normal"> 959</span>
<span class="normal"> 960</span>
<span class="normal"> 961</span>
<span class="normal"> 962</span>
<span class="normal"> 963</span>
<span class="normal"> 964</span>
<span class="normal"> 965</span>
<span class="normal"> 966</span>
<span class="normal"> 967</span>
<span class="normal"> 968</span>
<span class="normal"> 969</span>
<span class="normal"> 970</span>
<span class="normal"> 971</span>
<span class="normal"> 972</span>
<span class="normal"> 973</span>
<span class="normal"> 974</span>
<span class="normal"> 975</span>
<span class="normal"> 976</span>
<span class="normal"> 977</span>
<span class="normal"> 978</span>
<span class="normal"> 979</span>
<span class="normal"> 980</span>
<span class="normal"> 981</span>
<span class="normal"> 982</span>
<span class="normal"> 983</span>
<span class="normal"> 984</span>
<span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeQPNN</span><span class="p">(</span><span class="n">QPNN</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class for experimental modelling of QPNNs based on three-level system photon subtraction/addition nonlinearities</span>
<span class="sd">    that power a tree-type photonic cluster state generation protocol.</span>

<span class="sd">    Here, we extend upon the QPNN model further, now incorporating both imperfections as well as the cavity-assisted</span>
<span class="sd">    three-level system scattering nonlinearity introduced in [J. R. Basani *et al*., &quot;Universal logical quantum</span>
<span class="sd">    photonic neural network processor via cavity-assisted interactions&quot;, *npj Quantum Inf* **11**, 142 (2025)](</span>
<span class="sd">    https://doi.org/10.1038/s41534-025-01096-9). Additionally, this model is specifically designed for compatibility</span>
<span class="sd">    with the tree-type photonic cluster state generation protocol outlined in [J. Ewaniuk *et al*., &quot;Large-Scale</span>
<span class="sd">    Tree-Type Photonic Cluster State Generation with Recurrent Quantum Photonic Neural Networks&quot;, arXiv:2505.14628</span>
<span class="sd">    [quant-ph]](https://doi.org/10.48550/arXiv.2505.14628). As in `IdealQPNN`, a provided truth table defines the</span>
<span class="sd">    training set, however, this set is more involved than the previous models. When generating trees, the QPNN must</span>
<span class="sd">    perform photon-number-dependent operations, responding only to the input photons without active adjustment. As a</span>
<span class="sd">    result, there are multiple training subsets for different numbers of photons, and more specifically different</span>
<span class="sd">    tree unit cells that must be formed.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        n (int): number of photons, $n$</span>
<span class="sd">        m (int): number of optical modes, $m$</span>
<span class="sd">        L (int): number of layers, $L$</span>
<span class="sd">        b (int): maximum number of branches in the tree, $b\\equiv\\max\\{\\vec{b}\\}$</span>
<span class="sd">        N (int): dimension of the second quantization Fock basis for $n$ photons and $m$ optical modes</span>
<span class="sd">        Ns (tuple): tuple of $b + 1$ dimensions of the second quantization Fock bases for $n$ photons and $m$ optical</span>
<span class="sd">            modes for all $1 \\leq n \\leq b + 1$</span>
<span class="sd">        meshes (tuple): tuple of $L$ objects containing methods that allow each linear layer (i.e. rectangular</span>
<span class="sd">            Mach-Zehnder interferometer meshes) to be encoded</span>
<span class="sd">        ell_mzi (tuple): nominal loss for a Mach-Zehnder interferometer in dB, where the first (second) element is the</span>
<span class="sd">            mean (standard deviation) of a normal distribution from which those for each individual interferometer is</span>
<span class="sd">            selected</span>
<span class="sd">        ell_ps (tuple): nominal loss for a phase shifter in dB, where the first (second) element is the mean (standard</span>
<span class="sd">            deviation) of a normal distribution from which those for each individual output phase shifter is selected</span>
<span class="sd">        t_dc (tuple): directional coupler splitting ratios (T:R) as decimal values, where the first (second) element is</span>
<span class="sd">            the mean (standard deviation) of a normal distribution from which those for each individual nominally 50:50</span>
<span class="sd">            coupler is selected</span>
<span class="sd">        transformers (tuple): tuple of $b + 1$ objects containing methods that compute multi-photon unitary</span>
<span class="sd">            transformations of the linear layers for all $1 \\leq n \\leq b + 1$</span>
<span class="sd">        varphi (tuple): tuple of the phase shifts applied to the subtracted photon, followed by that applied to the</span>
<span class="sd">            remaining photons, for the 3LS photon $\\mp$ nonlinearity, in $\\text{rad}$, $(\\varphi_1, \\varphi2)$</span>
<span class="sd">        nls (tuple): tuple of $b + 1$ $N\\times N$ arrays, the $b + 1$ matrix representations of a set of single-site</span>
<span class="sd">            3LS photon $\\mp$ nonlinearities resolved in the Fock bases for all $1 \\leq n \\leq b + 1$</span>
<span class="sd">        K (tuple): arrays containing the numbers of input-target state pairs in the QPNN training set for each</span>
<span class="sd">            $1 \\leq n \\leq b + 1$, per unit cell operation, defaults to a tuple of zeros if none provided</span>
<span class="sd">        psi_in (tuple): arrays containing the input states of the QPNN training set, resolved in the $2^n$-dimensional</span>
<span class="sd">            computational bases, for each $1 \\leq n \\leq b + 1$, defaults to a tuple of empty arrays if none provided</span>
<span class="sd">        psi_targ (tuple): arrays containing the target states of the QPNN training set, resolved in the</span>
<span class="sd">            $2^n$-dimensional computational bases, for each $1 \\leq n \\leq b + 1$, defaults to a tuple of empty</span>
<span class="sd">            arrays if none provided</span>
<span class="sd">        comp_indices (tuple): arrays containing the indices of each second quantization Fock basis, for each</span>
<span class="sd">            $1 \\leq n \\leq b + 1$, that correspond to each possible unit cell operation, defaults to a tuple of empty</span>
<span class="sd">            arrays if none provided</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">L</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">varphi</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span>
        <span class="n">ell_mzi</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
        <span class="n">ell_ps</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
        <span class="n">t_dc</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
        <span class="n">training_set</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialization of a Tree QPNN instance.</span>

<span class="sd">        Each piece of the QPNN architecture is instantiated and stored as an attribute alongside relevant parameters.</span>

<span class="sd">        Args:</span>
<span class="sd">            b: number of branches in the tree, $b$</span>
<span class="sd">            L: number of layers, $L$</span>
<span class="sd">            varphi: tuple of the phase shifts applied to the subtracted photon, followed by that applied to the</span>
<span class="sd">                remaining photons, for the 3LS photon $\\mp$ nonlinearity, in $\\text{rad}$, $(\\varphi_1, \\varphi2)$</span>
<span class="sd">            ell_mzi: nominal loss for a Mach-Zehnder interferometer in dB, where the first (second) element is the mean</span>
<span class="sd">                (standard deviation) of a normal distribution from which those for each individual interferometer is</span>
<span class="sd">                selected</span>
<span class="sd">            ell_ps: nominal loss for a phase shifter in dB, where the first (second) element is the mean (standard</span>
<span class="sd">                deviation) of a normal distribution from which those for each individual output phase shifter is</span>
<span class="sd">                selected</span>
<span class="sd">            t_dc: directional coupler splitting ratios (T:R) as decimal values, where the first (second) element is the</span>
<span class="sd">                mean (standard deviation) of a normal distribution from which those for each individual nominally 50:50</span>
<span class="sd">                coupler is selected</span>
<span class="sd">            training_set: tuple of three tuples, the first two of which are the input and target states resolved in</span>
<span class="sd">                the computational basis for each $1 \\leq n \\leq b + 1$, the last of which contains the</span>
<span class="sd">                computational basis indices for each unit cell operation that exists for each $n$</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">m</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>

        <span class="c1"># instantiate L Clements meshes, with losses and routing errors, for encoding the linear layers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ell_mzi</span> <span class="o">=</span> <span class="n">ell_mzi</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ell_ps</span> <span class="o">=</span> <span class="n">ell_ps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_dc</span> <span class="o">=</span> <span class="n">t_dc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meshes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">Mesh</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imperfections</span> <span class="o">=</span> <span class="n">DEFAULT</span>

        <span class="c1"># instantiate transfomers for the multi-photon unitary transformations of the layers, for all 1 &lt;= n &lt;= b + 1</span>
        <span class="n">transformers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">Ns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">transformers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SecqTransformer</span><span class="p">(</span><span class="n">_n</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>
            <span class="n">Ns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">transformers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transformers</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">transformers</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ns</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">Ns</span><span class="p">)</span>

        <span class="c1"># store nonlinear phase shifts, construct the 3LS photon -/+ nonlinear unitaries for all 1 &lt;= n &lt;= b + 1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">varphi</span> <span class="o">=</span> <span class="n">varphi</span>
        <span class="n">nls</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">nls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">build_photon_mp</span><span class="p">(</span><span class="n">_n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="n">varphi</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nls</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">nls</span><span class="p">)</span>

        <span class="c1"># prepare the training set attributes whether they were provided or not</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">training_set</span> <span class="o">=</span> <span class="n">training_set</span> <span class="k">if</span> <span class="n">training_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">((),</span> <span class="p">(),</span> <span class="p">())</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">training_set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Training set for the unit cell generation functionality of the QPNN.</span>

<span class="sd">        Returns:</span>
<span class="sd">            psi_in: tuple of the input states resolved in the computational basis for each $1 \\leq n \\leq b + 1$</span>
<span class="sd">            psi_targ: tuple of the target states resolved in the computational basis for each $1 \\leq n \\leq b + 1$</span>
<span class="sd">            comp_indices: computational basis indices for each unit cell operation that exists for each $n$</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">psi_in</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">psi_targ</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">comp_indices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="n">psi_in</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi_in</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">psi_targ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi_targ</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">comp_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comp_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">psi_in</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">psi_targ</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">comp_indices</span><span class="p">)</span>

    <span class="nd">@training_set</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">training_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tset</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Training set for the unit cell generation functionality of the QPNN.</span>

<span class="sd">        Args:</span>
<span class="sd">            tset: tuple of three tuples, the first two of which are the input and target states resolved in the</span>
<span class="sd">                computational basis for each $1 \\leq n \\leq b + 1$, the last of which contains the computational</span>
<span class="sd">                basis indices for each unit cell operation that exists for each $n$</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tset</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">psi_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(())]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
            <span class="n">psi_targ</span> <span class="o">=</span> <span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(())]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
            <span class="n">comp_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(())]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
            <span class="n">K</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">psi_in</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">psi_targ</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">comp_indices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">K</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
                <span class="n">psi_in</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">tset</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">psi_targ</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">tset</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">comp_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">tset</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span>
                <span class="n">K</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">psi_in</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">psi_in</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">psi_in</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">psi_targ</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">psi_targ</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comp_indices</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">comp_indices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">imperfections</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Component-level imperfection values for each interferometer mesh in the QPNN.</span>

<span class="sd">        See `ImperfectQPNN.imperfections` for more details.</span>

<span class="sd">        Returns:</span>
<span class="sd">            ells_mzi: $L\\times m\\times m$ array containing the fractinal loss per arm of each of the $L$</span>
<span class="sd">                interferometer meshes, for each column of MZIs respectively</span>
<span class="sd">            ells_ps: $L\\times m$ array containing the fractional loss for each of the output phase shifters</span>
<span class="sd">                in each of the $L$ interferometer meshes</span>
<span class="sd">            ts_dc: $L\\times 2\\times m(m-1)/2$ array containing the splitting ratio (T:R) of each directional</span>
<span class="sd">                coupler in each of the $L$ interferometer meshes, organized such that each column corresponds to one</span>
<span class="sd">                MZI, the top row being the first directional coupler and the bottom being the second, where the MZIs</span>
<span class="sd">                are ordered from top to bottom followed by left to right across each mesh</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ells_mzi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">ells_ps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">ts_dc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
            <span class="n">ells_mzi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ell_mzi</span>
            <span class="n">ells_ps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ell_ps</span>
            <span class="n">ts_dc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">t_dc</span>
        <span class="k">return</span> <span class="n">ells_mzi</span><span class="p">,</span> <span class="n">ells_ps</span><span class="p">,</span> <span class="n">ts_dc</span>

    <span class="nd">@imperfections</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">imperfections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imp</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Component-level imperfection values for each interferometer mesh in the QPNN.</span>

<span class="sd">        Args:</span>
<span class="sd">            imp: Tuple of arrays, the first of which is an $L\\times m\\times m$ array containing the</span>
<span class="sd">                percentage loss per arm of each of the $L$ interferometer meshes, for each column of MZIs</span>
<span class="sd">                respectively; the second of which is an $L\\times m$ array containing the percentage loss for each of</span>
<span class="sd">                the output phase shifters in each of the $L$ interferometer meshes; the third of which is an</span>
<span class="sd">                $L\\times 2\\times m(m-1)/2$ array containing the splitting ratio (T:R) of each directional coupler</span>
<span class="sd">                in each of the $L$ interferometer meshes, organized such that each column corresponds to one MZI,</span>
<span class="sd">                the top row being the first directional coupler and the bottom being the second, where the MZIs are</span>
<span class="sd">                ordered from top to bottom followed by left to right across each mesh; if None, then this function</span>
<span class="sd">                will use the nominal imperfection attributes to generate the component-level imperfection values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">imp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># for each layer, compute and apply new loss and splitting ratio values from their respective distributions</span>
            <span class="n">ells_mzi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">ells_ps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">ts_dc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
                <span class="n">ells_mzi</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span>
                    <span class="mf">1.0</span> <span class="o">-</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ell_mzi</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ell_mzi</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ell_mzi</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span>
                <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">))</span>
                <span class="n">ells_ps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span>
                    <span class="mf">1.0</span> <span class="o">-</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ell_ps</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">ell_ps</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ell_ps</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">ts_dc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">t_dc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_dc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ells_mzi</span><span class="p">,</span> <span class="n">ells_ps</span><span class="p">,</span> <span class="n">ts_dc</span> <span class="o">=</span> <span class="n">imp</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meshes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ell_mzi</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ells_mzi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meshes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ell_ps</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ells_ps</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">meshes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">t_dc</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ts_dc</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build matrix representations of the QPNN from all its layers and components, for operation on</span>
<span class="sd">        $1 \\leq n \\leq b + 1$ photons.</span>

<span class="sd">        This method calculates the system function of the QPNN as introduced at the top of this module, yet does so</span>
<span class="sd">        for each potential number of input photons, $1 \\leq n \\leq b + 1$.</span>

<span class="sd">        Args:</span>
<span class="sd">            phi: $L\\times m(m-1)/2$ phase shifts, $\\phi$, where the ith row contains those for each MZI in the</span>
<span class="sd">                ith layer</span>
<span class="sd">            theta: $L\\times m(m-1)/2$ phase shifts, $\\theta$, where the ith row contains those for each MZI in the</span>
<span class="sd">                ith layer</span>
<span class="sd">            delta: $L\\times m$ phase shifts, $\\delta$, where the ith row contains those for each mode at the output</span>
<span class="sd">                of the mesh in the ith layer</span>

<span class="sd">        Returns:</span>
<span class="sd">            S: a tuple of $b + 1$ $N\\times N$ arrays, the matrix representations of the QPNN resolved in the</span>
<span class="sd">                $N$-dimensional second quantization Fock bases for all $1 \\leq n \\leq b + 1$</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># encode the single-photon unitary matrices for each linear layer in the Clements configuration</span>
        <span class="n">single_photon_Us</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meshes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span>
        <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">n_photon_S</span><span class="p">(</span><span class="n">transformer</span><span class="p">:</span> <span class="n">SecqTransformer</span><span class="p">,</span> <span class="n">nl</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">N</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp_ndarray</span><span class="p">:</span>
            <span class="c1"># perform the multi-photon unitary transformations for each linear layer</span>
            <span class="n">multi_photon_Us</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">)(</span><span class="n">single_photon_Us</span><span class="p">)</span>

            <span class="c1"># for each linear layer up to the last one, multiply the nonlinear unitary and multi-photon unitary together</span>
            <span class="n">layers</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">PhiU</span><span class="p">:</span> <span class="n">nl</span> <span class="o">@</span> <span class="n">PhiU</span><span class="p">)(</span><span class="n">multi_photon_Us</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

            <span class="c1"># stack the layers together, including the final linear layer</span>
            <span class="n">layers</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">layers</span><span class="p">,</span> <span class="n">multi_photon_Us</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">))))</span>

            <span class="c1"># multiply all the layers together</span>
            <span class="n">Sn</span><span class="p">:</span> <span class="n">jnp_ndarray</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">matmul</span><span class="p">,</span> <span class="n">layers</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">Sn</span>

        <span class="c1"># construct the matrix representations for all numbers of photons, 1 &lt;= n &lt;= b + 1</span>
        <span class="n">S</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="n">tree_map</span><span class="p">(</span><span class="n">n_photon_S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nls</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ns</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">S</span>

    <span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calc_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DTypeLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the cost function for the QPNN.</span>

<span class="sd">        This method calculates the cost function of the QPNN as introduced at the top of this module. It relies on a</span>
<span class="sd">        training set and will thus throw an error if one has not been provided. Specifically, it includes all</span>
<span class="sd">        input-target pairs for all unit cell operations for all numbers of photons $1 \\leq n \\leq b + 1$,</span>
<span class="sd">        before averaging.</span>

<span class="sd">        Args:</span>
<span class="sd">            phi: $L\\times m(m-1)/2$ phase shifts, $\\phi$, where the ith row contains those for each MZI in the</span>
<span class="sd">                ith layer</span>
<span class="sd">            theta: $L\\times m(m-1)/2$ phase shifts, $\\theta$, where the ith row contains those for each MZI in the</span>
<span class="sd">                ith layer</span>
<span class="sd">            delta: $L\\times m$ phase shifts, $\\delta$, where the ith row contains those for each mode at the output</span>
<span class="sd">                of the mesh in the ith layer</span>

<span class="sd">        Returns:</span>
<span class="sd">            C: cost (i.e. network error) of the QPNN</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check that a training set has been provided</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;No training set was provided for the QPNN.&quot;</span>

        <span class="c1"># construct the QPNN system function in all $N$-dimensional Fock bases for all 1 &lt;= n &lt;= b + 1</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">n_photon_succ_rates</span><span class="p">(</span>
            <span class="n">Sn</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">psi_in_n</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">psi_targ_n</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">comp_inds_n</span><span class="p">:</span> <span class="n">jnp_ndarray</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp_ndarray</span><span class="p">:</span>
            <span class="nd">@vmap</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">n_photon_unit_cell_succ_rates</span><span class="p">(</span><span class="n">inds</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp_ndarray</span><span class="p">:</span>
                <span class="n">psi_out_n</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psi</span><span class="p">:</span> <span class="n">Sn</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">inds</span><span class="p">)]</span> <span class="o">@</span> <span class="n">psi</span><span class="p">)(</span><span class="n">psi_in_n</span><span class="p">)</span>
                <span class="n">succ_uc</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psit</span><span class="p">,</span> <span class="n">psio</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">psit</span><span class="p">),</span> <span class="n">psio</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)(</span><span class="n">psi_targ_n</span><span class="p">,</span> <span class="n">psi_out_n</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">succ_uc</span>

            <span class="n">succ_rates</span> <span class="o">=</span> <span class="n">n_photon_unit_cell_succ_rates</span><span class="p">(</span><span class="n">comp_inds_n</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">succ_rates</span><span class="p">)</span>

        <span class="c1"># compute the success rates for each 1 &lt;= n &lt;= b + 1</span>
        <span class="n">succ_rates</span> <span class="o">=</span> <span class="n">tree_map</span><span class="p">(</span><span class="n">n_photon_succ_rates</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi_in</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi_targ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp_indices</span><span class="p">)</span>

        <span class="c1"># put everything together, take the mean, then calculate cost</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">succ_rates</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">cost</span>

    <span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calc_overall_performance_measures</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">DTypeLike</span><span class="p">,</span> <span class="n">DTypeLike</span><span class="p">,</span> <span class="n">DTypeLike</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the overall fidelity, success rate and logical rate of the QPNN.</span>

<span class="sd">        This method calculates the fidelity, success rate, and logical rate of the QPNN as introduced at the top of</span>
<span class="sd">        this module. It relies on a training set and will thus throw an error if one has not been provided.</span>
<span class="sd">        Specifically, it includes all input-target pairs for all unit cell operations for all numbers of photons $1</span>
<span class="sd">        \\leq n \\leq b + 1$, before averaging.</span>

<span class="sd">        Args:</span>
<span class="sd">            phi: $L\\times m(m-1)/2$ phase shifts, $\\phi$, where the ith row contains those for each MZI in the</span>
<span class="sd">                ith layer</span>
<span class="sd">            theta: $L\\times m(m-1)/2$ phase shifts, $\\theta$, where the ith row contains those for each MZI in the</span>
<span class="sd">                ith layer</span>
<span class="sd">            delta: $L\\times m$ phase shifts, $\\delta$, where the ith row contains those for each mode at the output</span>
<span class="sd">                of the mesh in the ith layer</span>

<span class="sd">        Returns:</span>
<span class="sd">            fid: overall fidelity of the QPNN</span>
<span class="sd">            succ_rate: overall success rate of the QPNN</span>
<span class="sd">            logi_rate: overall logical rate of the QPNN</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check that a training set has been provided</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;No training set was provided for the QPNN.&quot;</span>

        <span class="c1"># construct the QPNN system function in all $N$-dimensional Fock bases for all 1 &lt;= n &lt;= b + 1</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">measures</span><span class="p">(</span>
            <span class="n">Sn</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">psi_in_n</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">psi_targ_n</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">comp_inds_n</span><span class="p">:</span> <span class="n">jnp_ndarray</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="nd">@vmap</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">measures_per_unit_cell</span><span class="p">(</span><span class="n">inds</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
                <span class="n">psi_out_n</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psi</span><span class="p">:</span> <span class="n">Sn</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">inds</span><span class="p">)]</span> <span class="o">@</span> <span class="n">psi</span><span class="p">)(</span><span class="n">psi_in_n</span><span class="p">)</span>
                <span class="n">succ</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psit</span><span class="p">,</span> <span class="n">psio</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">psit</span><span class="p">),</span> <span class="n">psio</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)(</span><span class="n">psi_targ_n</span><span class="p">,</span> <span class="n">psi_out_n</span><span class="p">)</span>
                <span class="n">logi</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psio</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">psio</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))(</span><span class="n">psi_out_n</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">succ</span><span class="p">,</span> <span class="n">logi</span>

            <span class="n">succ_rates</span><span class="p">,</span> <span class="n">logi_rates</span> <span class="o">=</span> <span class="n">measures_per_unit_cell</span><span class="p">(</span><span class="n">comp_inds_n</span><span class="p">)</span>
            <span class="n">fids</span> <span class="o">=</span> <span class="n">succ_rates</span> <span class="o">/</span> <span class="n">logi_rates</span>
            <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">fids</span><span class="p">),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">succ_rates</span><span class="p">),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">logi_rates</span><span class="p">)</span>

        <span class="c1"># map through the different numbers of photons and unit cell operations, evaluating performance on the way</span>
        <span class="n">meas</span> <span class="o">=</span> <span class="n">tree_map</span><span class="p">(</span><span class="n">measures</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi_in</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi_targ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp_indices</span><span class="p">)</span>
        <span class="n">meas_T</span> <span class="o">=</span> <span class="n">tree_transpose</span><span class="p">(</span>
            <span class="n">outer_treedef</span><span class="o">=</span><span class="n">tree_structure</span><span class="p">(</span><span class="n">S</span><span class="p">),</span>
            <span class="n">inner_treedef</span><span class="o">=</span><span class="n">tree_structure</span><span class="p">(</span><span class="n">meas</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">pytree_to_transpose</span><span class="o">=</span><span class="n">meas</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">fids</span><span class="p">,</span> <span class="n">succ_rates</span><span class="p">,</span> <span class="n">logi_rates</span> <span class="o">=</span> <span class="n">meas_T</span>

        <span class="c1"># compute the overall fidelity, success rate &amp; logical rate, including all operations in the mean</span>
        <span class="n">fid</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">fids</span><span class="p">))</span>
        <span class="n">succ_rate</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">succ_rates</span><span class="p">))</span>
        <span class="n">logi_rate</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">logi_rates</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">fid</span><span class="p">,</span> <span class="n">succ_rate</span><span class="p">,</span> <span class="n">logi_rate</span>

    <span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">calc_unit_cell_performance_measures</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the fidelities, success rates and logical rates of the QPNN for each individual unit cell</span>
<span class="sd">        operation required for tree formation.</span>

<span class="sd">        This method calculates the fidelity, success rate, and logical rate of the QPNN as introduced at the top of</span>
<span class="sd">        this module. It relies on a training set and will thus throw an error if one has not been provided.</span>
<span class="sd">        Specifically, each returned value includes only the input-target pairs for a specific unit cell operation.</span>
<span class="sd">        For each measure, a tuple is returned. The elements of this tuple are arrays, each for a specific number of</span>
<span class="sd">        photons in increasing order for all $1 \\leq n \\leq b + 1$. There may be multiple unit cell operations</span>
<span class="sd">        required for a given $n$, so these arrays may contain multiple values. The specific dimensions depend in a</span>
<span class="sd">        complicated way on $b$, which is why they are not provided here in general.</span>

<span class="sd">        Args:</span>
<span class="sd">            phi: $L\\times m(m-1)/2$ phase shifts, $\\phi$, where the ith row contains those for each MZI in the</span>
<span class="sd">                ith layer</span>
<span class="sd">            theta: $L\\times m(m-1)/2$ phase shifts, $\\theta$, where the ith row contains those for each MZI in the</span>
<span class="sd">                ith layer</span>
<span class="sd">            delta: $L\\times m$ phase shifts, $\\delta$, where the ith row contains those for each mode at the output</span>
<span class="sd">                of the mesh in the ith layer</span>

<span class="sd">        Returns:</span>
<span class="sd">            fids: tuple containing the fidelities of the QPNN for each unit cell operation and each $n$</span>
<span class="sd">            succ_rates: tuple containing the success rates of the QPNN for each unit cell operation and each $n$</span>
<span class="sd">            logi_rates: tuple containing the logical rates of the QPNN for each unit cell operation and each $n$</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check that a training set has been provided</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;No training set was provided for the QPNN.&quot;</span>

        <span class="c1"># construct the QPNN system function in all $N$-dimensional Fock bases for all 1 &lt;= n &lt;= b + 1</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">measures</span><span class="p">(</span>
            <span class="n">Sn</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">psi_in_n</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">psi_targ_n</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">comp_inds_n</span><span class="p">:</span> <span class="n">jnp_ndarray</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="nd">@vmap</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">measures_per_unit_cell</span><span class="p">(</span><span class="n">inds</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
                <span class="n">psi_out_n</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psi</span><span class="p">:</span> <span class="n">Sn</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">inds</span><span class="p">)]</span> <span class="o">@</span> <span class="n">psi</span><span class="p">)(</span><span class="n">psi_in_n</span><span class="p">)</span>
                <span class="n">succ_uc</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psit</span><span class="p">,</span> <span class="n">psio</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">psit</span><span class="p">),</span> <span class="n">psio</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)(</span><span class="n">psi_targ_n</span><span class="p">,</span> <span class="n">psi_out_n</span><span class="p">)</span>
                <span class="n">logi_uc</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psio</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">psio</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))(</span><span class="n">psi_out_n</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">succ_uc</span><span class="p">,</span> <span class="n">logi_uc</span>

            <span class="n">succ_rates</span><span class="p">,</span> <span class="n">logi_rates</span> <span class="o">=</span> <span class="n">measures_per_unit_cell</span><span class="p">(</span><span class="n">comp_inds_n</span><span class="p">)</span>
            <span class="n">succ_rate</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">succ</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">succ</span><span class="p">))(</span><span class="n">succ_rates</span><span class="p">)</span>
            <span class="n">logi_rate</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">logi</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">logi</span><span class="p">))(</span><span class="n">logi_rates</span><span class="p">)</span>
            <span class="n">fid</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">succ</span><span class="p">,</span> <span class="n">logi</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">succ</span> <span class="o">/</span> <span class="n">logi</span><span class="p">))(</span><span class="n">succ_rates</span><span class="p">,</span> <span class="n">logi_rates</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fid</span><span class="p">,</span> <span class="n">succ_rate</span><span class="p">,</span> <span class="n">logi_rate</span>

        <span class="c1"># map through the different numbers of photons and unit cell operations, evaluating performance on the way</span>
        <span class="n">meas</span> <span class="o">=</span> <span class="n">tree_map</span><span class="p">(</span><span class="n">measures</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi_in</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi_targ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp_indices</span><span class="p">)</span>
        <span class="n">meas_T</span> <span class="o">=</span> <span class="n">tree_transpose</span><span class="p">(</span>
            <span class="n">outer_treedef</span><span class="o">=</span><span class="n">tree_structure</span><span class="p">(</span><span class="n">S</span><span class="p">),</span>
            <span class="n">inner_treedef</span><span class="o">=</span><span class="n">tree_structure</span><span class="p">(</span><span class="n">meas</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
            <span class="n">pytree_to_transpose</span><span class="o">=</span><span class="n">meas</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">fids</span><span class="p">,</span> <span class="n">succ_rates</span><span class="p">,</span> <span class="n">logi_rates</span> <span class="o">=</span> <span class="n">meas_T</span>

        <span class="k">return</span> <span class="n">fids</span><span class="p">,</span> <span class="n">succ_rates</span><span class="p">,</span> <span class="n">logi_rates</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-function">


<h3 id="quotonic.qpnn.TreeQPNN.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">varphi</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span> <span class="n">ell_mzi</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">ell_ps</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">t_dc</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">training_set</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

<a href="#quotonic.qpnn.TreeQPNN.__init__" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Initialization of a Tree QPNN instance.</p>
<p>Each piece of the QPNN architecture is instantiated and stored as an attribute alongside relevant parameters.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>b</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of branches in the tree, <span class="arithmatex">\(b\)</span></p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>L</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of layers, <span class="arithmatex">\(L\)</span></p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>varphi</code>
            </td>
            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple of the phase shifts applied to the subtracted photon, followed by that applied to the
remaining photons, for the 3LS photon <span class="arithmatex">\(\mp\)</span> nonlinearity, in <span class="arithmatex">\(\text{rad}\)</span>, <span class="arithmatex">\((\varphi_1, \varphi2)\)</span></p>
              </div>
            </td>
            <td>
                  <code>(0.0, <span title="numpy.pi">pi</span>)</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>ell_mzi</code>
            </td>
            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>nominal loss for a Mach-Zehnder interferometer in dB, where the first (second) element is the mean
(standard deviation) of a normal distribution from which those for each individual interferometer is
selected</p>
              </div>
            </td>
            <td>
                  <code>(0.0, 0.0)</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>ell_ps</code>
            </td>
            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>nominal loss for a phase shifter in dB, where the first (second) element is the mean (standard
deviation) of a normal distribution from which those for each individual output phase shifter is
selected</p>
              </div>
            </td>
            <td>
                  <code>(0.0, 0.0)</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>t_dc</code>
            </td>
            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>directional coupler splitting ratios (T:R) as decimal values, where the first (second) element is the
mean (standard deviation) of a normal distribution from which those for each individual nominally 50:50
coupler is selected</p>
              </div>
            </td>
            <td>
                  <code>(0.5, 0.0)</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>training_set</code>
            </td>
            <td>
                  <code><span title="tuple">tuple</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple of three tuples, the first two of which are the input and target states resolved in
the computational basis for each <span class="arithmatex">\(1 \leq n \leq b + 1\)</span>, the last of which contains the
computational basis indices for each unit cell operation that exists for each <span class="arithmatex">\(n\)</span></p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/qpnn.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span>
<span class="normal">673</span>
<span class="normal">674</span>
<span class="normal">675</span>
<span class="normal">676</span>
<span class="normal">677</span>
<span class="normal">678</span>
<span class="normal">679</span>
<span class="normal">680</span>
<span class="normal">681</span>
<span class="normal">682</span>
<span class="normal">683</span>
<span class="normal">684</span>
<span class="normal">685</span>
<span class="normal">686</span>
<span class="normal">687</span>
<span class="normal">688</span>
<span class="normal">689</span>
<span class="normal">690</span>
<span class="normal">691</span>
<span class="normal">692</span>
<span class="normal">693</span>
<span class="normal">694</span>
<span class="normal">695</span>
<span class="normal">696</span>
<span class="normal">697</span>
<span class="normal">698</span>
<span class="normal">699</span>
<span class="normal">700</span>
<span class="normal">701</span>
<span class="normal">702</span>
<span class="normal">703</span>
<span class="normal">704</span>
<span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">L</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">varphi</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span>
    <span class="n">ell_mzi</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
    <span class="n">ell_ps</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
    <span class="n">t_dc</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
    <span class="n">training_set</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialization of a Tree QPNN instance.</span>

<span class="sd">    Each piece of the QPNN architecture is instantiated and stored as an attribute alongside relevant parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        b: number of branches in the tree, $b$</span>
<span class="sd">        L: number of layers, $L$</span>
<span class="sd">        varphi: tuple of the phase shifts applied to the subtracted photon, followed by that applied to the</span>
<span class="sd">            remaining photons, for the 3LS photon $\\mp$ nonlinearity, in $\\text{rad}$, $(\\varphi_1, \\varphi2)$</span>
<span class="sd">        ell_mzi: nominal loss for a Mach-Zehnder interferometer in dB, where the first (second) element is the mean</span>
<span class="sd">            (standard deviation) of a normal distribution from which those for each individual interferometer is</span>
<span class="sd">            selected</span>
<span class="sd">        ell_ps: nominal loss for a phase shifter in dB, where the first (second) element is the mean (standard</span>
<span class="sd">            deviation) of a normal distribution from which those for each individual output phase shifter is</span>
<span class="sd">            selected</span>
<span class="sd">        t_dc: directional coupler splitting ratios (T:R) as decimal values, where the first (second) element is the</span>
<span class="sd">            mean (standard deviation) of a normal distribution from which those for each individual nominally 50:50</span>
<span class="sd">            coupler is selected</span>
<span class="sd">        training_set: tuple of three tuples, the first two of which are the input and target states resolved in</span>
<span class="sd">            the computational basis for each $1 \\leq n \\leq b + 1$, the last of which contains the</span>
<span class="sd">            computational basis indices for each unit cell operation that exists for each $n$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">m</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>

    <span class="c1"># instantiate L Clements meshes, with losses and routing errors, for encoding the linear layers</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ell_mzi</span> <span class="o">=</span> <span class="n">ell_mzi</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">ell_ps</span> <span class="o">=</span> <span class="n">ell_ps</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">t_dc</span> <span class="o">=</span> <span class="n">t_dc</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">meshes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">Mesh</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">)])</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">imperfections</span> <span class="o">=</span> <span class="n">DEFAULT</span>

    <span class="c1"># instantiate transfomers for the multi-photon unitary transformations of the layers, for all 1 &lt;= n &lt;= b + 1</span>
    <span class="n">transformers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Ns</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">transformers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SecqTransformer</span><span class="p">(</span><span class="n">_n</span><span class="p">,</span> <span class="n">m</span><span class="p">))</span>
        <span class="n">Ns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">transformers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">N</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">transformers</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">transformers</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Ns</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">Ns</span><span class="p">)</span>

    <span class="c1"># store nonlinear phase shifts, construct the 3LS photon -/+ nonlinear unitaries for all 1 &lt;= n &lt;= b + 1</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">varphi</span> <span class="o">=</span> <span class="n">varphi</span>
    <span class="n">nls</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">nls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">build_photon_mp</span><span class="p">(</span><span class="n">_n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="o">*</span><span class="n">varphi</span><span class="p">)))</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nls</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">nls</span><span class="p">)</span>

    <span class="c1"># prepare the training set attributes whether they were provided or not</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">training_set</span> <span class="o">=</span> <span class="n">training_set</span> <span class="k">if</span> <span class="n">training_set</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">((),</span> <span class="p">(),</span> <span class="p">())</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>






<div class="doc doc-object doc-attribute">



<h3 id="quotonic.qpnn.TreeQPNN.training_set" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">training_set</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
      <small class="doc doc-label doc-label-writable"><code>writable</code></small>
  </span>

<a href="#quotonic.qpnn.TreeQPNN.training_set" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Training set for the unit cell generation functionality of the QPNN.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>psi_in</code></td>            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple of the input states resolved in the computational basis for each <span class="arithmatex">\(1 \leq n \leq b + 1\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>psi_targ</code></td>            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple of the target states resolved in the computational basis for each <span class="arithmatex">\(1 \leq n \leq b + 1\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>comp_indices</code></td>            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>computational basis indices for each unit cell operation that exists for each <span class="arithmatex">\(n\)</span></p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

    </div>

</div>






<div class="doc doc-object doc-attribute">



<h3 id="quotonic.qpnn.TreeQPNN.imperfections" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">imperfections</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
      <small class="doc doc-label doc-label-writable"><code>writable</code></small>
  </span>

<a href="#quotonic.qpnn.TreeQPNN.imperfections" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Component-level imperfection values for each interferometer mesh in the QPNN.</p>
<p>See <code>ImperfectQPNN.imperfections</code> for more details.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>ells_mzi</code></td>            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m\times m\)</span> array containing the fractinal loss per arm of each of the <span class="arithmatex">\(L\)</span>
interferometer meshes, for each column of MZIs respectively</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>ells_ps</code></td>            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m\)</span> array containing the fractional loss for each of the output phase shifters
in each of the <span class="arithmatex">\(L\)</span> interferometer meshes</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>ts_dc</code></td>            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times 2\times m(m-1)/2\)</span> array containing the splitting ratio (T:R) of each directional
coupler in each of the <span class="arithmatex">\(L\)</span> interferometer meshes, organized such that each column corresponds to one
MZI, the top row being the first directional coupler and the bottom being the second, where the MZIs
are ordered from top to bottom followed by left to right across each mesh</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

    </div>

</div>






<div class="doc doc-object doc-function">


<h3 id="quotonic.qpnn.TreeQPNN.build" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">build</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span></code>

<a href="#quotonic.qpnn.TreeQPNN.build" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Build matrix representations of the QPNN from all its layers and components, for operation on
<span class="arithmatex">\(1 \leq n \leq b + 1\)</span> photons.</p>
<p>This method calculates the system function of the QPNN as introduced at the top of this module, yet does so
for each potential number of input photons, <span class="arithmatex">\(1 \leq n \leq b + 1\)</span>.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>phi</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> phase shifts, <span class="arithmatex">\(\phi\)</span>, where the ith row contains those for each MZI in the
ith layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>theta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> phase shifts, <span class="arithmatex">\(\theta\)</span>, where the ith row contains those for each MZI in the
ith layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>delta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m\)</span> phase shifts, <span class="arithmatex">\(\delta\)</span>, where the ith row contains those for each mode at the output
of the mesh in the ith layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>S</code></td>            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>a tuple of <span class="arithmatex">\(b + 1\)</span> <span class="arithmatex">\(N\times N\)</span> arrays, the matrix representations of the QPNN resolved in the
<span class="arithmatex">\(N\)</span>-dimensional second quantization Fock bases for all <span class="arithmatex">\(1 \leq n \leq b + 1\)</span></p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/qpnn.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">831</span>
<span class="normal">832</span>
<span class="normal">833</span>
<span class="normal">834</span>
<span class="normal">835</span>
<span class="normal">836</span>
<span class="normal">837</span>
<span class="normal">838</span>
<span class="normal">839</span>
<span class="normal">840</span>
<span class="normal">841</span>
<span class="normal">842</span>
<span class="normal">843</span>
<span class="normal">844</span>
<span class="normal">845</span>
<span class="normal">846</span>
<span class="normal">847</span>
<span class="normal">848</span>
<span class="normal">849</span>
<span class="normal">850</span>
<span class="normal">851</span>
<span class="normal">852</span>
<span class="normal">853</span>
<span class="normal">854</span>
<span class="normal">855</span>
<span class="normal">856</span>
<span class="normal">857</span>
<span class="normal">858</span>
<span class="normal">859</span>
<span class="normal">860</span>
<span class="normal">861</span>
<span class="normal">862</span>
<span class="normal">863</span>
<span class="normal">864</span>
<span class="normal">865</span>
<span class="normal">866</span>
<span class="normal">867</span>
<span class="normal">868</span>
<span class="normal">869</span>
<span class="normal">870</span>
<span class="normal">871</span>
<span class="normal">872</span>
<span class="normal">873</span>
<span class="normal">874</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
<span class="k">def</span><span class="w"> </span><span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Build matrix representations of the QPNN from all its layers and components, for operation on</span>
<span class="sd">    $1 \\leq n \\leq b + 1$ photons.</span>

<span class="sd">    This method calculates the system function of the QPNN as introduced at the top of this module, yet does so</span>
<span class="sd">    for each potential number of input photons, $1 \\leq n \\leq b + 1$.</span>

<span class="sd">    Args:</span>
<span class="sd">        phi: $L\\times m(m-1)/2$ phase shifts, $\\phi$, where the ith row contains those for each MZI in the</span>
<span class="sd">            ith layer</span>
<span class="sd">        theta: $L\\times m(m-1)/2$ phase shifts, $\\theta$, where the ith row contains those for each MZI in the</span>
<span class="sd">            ith layer</span>
<span class="sd">        delta: $L\\times m$ phase shifts, $\\delta$, where the ith row contains those for each mode at the output</span>
<span class="sd">            of the mesh in the ith layer</span>

<span class="sd">    Returns:</span>
<span class="sd">        S: a tuple of $b + 1$ $N\\times N$ arrays, the matrix representations of the QPNN resolved in the</span>
<span class="sd">            $N$-dimensional second quantization Fock bases for all $1 \\leq n \\leq b + 1$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># encode the single-photon unitary matrices for each linear layer in the Clements configuration</span>
    <span class="n">single_photon_Us</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">meshes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span>
    <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">n_photon_S</span><span class="p">(</span><span class="n">transformer</span><span class="p">:</span> <span class="n">SecqTransformer</span><span class="p">,</span> <span class="n">nl</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">N</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp_ndarray</span><span class="p">:</span>
        <span class="c1"># perform the multi-photon unitary transformations for each linear layer</span>
        <span class="n">multi_photon_Us</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="n">transformer</span><span class="o">.</span><span class="n">transform</span><span class="p">)(</span><span class="n">single_photon_Us</span><span class="p">)</span>

        <span class="c1"># for each linear layer up to the last one, multiply the nonlinear unitary and multi-photon unitary together</span>
        <span class="n">layers</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">PhiU</span><span class="p">:</span> <span class="n">nl</span> <span class="o">@</span> <span class="n">PhiU</span><span class="p">)(</span><span class="n">multi_photon_Us</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

        <span class="c1"># stack the layers together, including the final linear layer</span>
        <span class="n">layers</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">layers</span><span class="p">,</span> <span class="n">multi_photon_Us</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">))))</span>

        <span class="c1"># multiply all the layers together</span>
        <span class="n">Sn</span><span class="p">:</span> <span class="n">jnp_ndarray</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">matmul</span><span class="p">,</span> <span class="n">layers</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Sn</span>

    <span class="c1"># construct the matrix representations for all numbers of photons, 1 &lt;= n &lt;= b + 1</span>
    <span class="n">S</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="n">tree_map</span><span class="p">(</span><span class="n">n_photon_S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nls</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ns</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">S</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>






<div class="doc doc-object doc-function">


<h3 id="quotonic.qpnn.TreeQPNN.calc_cost" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">calc_cost</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span></code>

<a href="#quotonic.qpnn.TreeQPNN.calc_cost" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Calculate the cost function for the QPNN.</p>
<p>This method calculates the cost function of the QPNN as introduced at the top of this module. It relies on a
training set and will thus throw an error if one has not been provided. Specifically, it includes all
input-target pairs for all unit cell operations for all numbers of photons <span class="arithmatex">\(1 \leq n \leq b + 1\)</span>,
before averaging.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>phi</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> phase shifts, <span class="arithmatex">\(\phi\)</span>, where the ith row contains those for each MZI in the
ith layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>theta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> phase shifts, <span class="arithmatex">\(\theta\)</span>, where the ith row contains those for each MZI in the
ith layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>delta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m\)</span> phase shifts, <span class="arithmatex">\(\delta\)</span>, where the ith row contains those for each mode at the output
of the mesh in the ith layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>C</code></td>            <td>
                  <code><span title="jax.typing.DTypeLike">DTypeLike</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>cost (i.e. network error) of the QPNN</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/qpnn.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">876</span>
<span class="normal">877</span>
<span class="normal">878</span>
<span class="normal">879</span>
<span class="normal">880</span>
<span class="normal">881</span>
<span class="normal">882</span>
<span class="normal">883</span>
<span class="normal">884</span>
<span class="normal">885</span>
<span class="normal">886</span>
<span class="normal">887</span>
<span class="normal">888</span>
<span class="normal">889</span>
<span class="normal">890</span>
<span class="normal">891</span>
<span class="normal">892</span>
<span class="normal">893</span>
<span class="normal">894</span>
<span class="normal">895</span>
<span class="normal">896</span>
<span class="normal">897</span>
<span class="normal">898</span>
<span class="normal">899</span>
<span class="normal">900</span>
<span class="normal">901</span>
<span class="normal">902</span>
<span class="normal">903</span>
<span class="normal">904</span>
<span class="normal">905</span>
<span class="normal">906</span>
<span class="normal">907</span>
<span class="normal">908</span>
<span class="normal">909</span>
<span class="normal">910</span>
<span class="normal">911</span>
<span class="normal">912</span>
<span class="normal">913</span>
<span class="normal">914</span>
<span class="normal">915</span>
<span class="normal">916</span>
<span class="normal">917</span>
<span class="normal">918</span>
<span class="normal">919</span>
<span class="normal">920</span>
<span class="normal">921</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
<span class="k">def</span><span class="w"> </span><span class="nf">calc_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DTypeLike</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the cost function for the QPNN.</span>

<span class="sd">    This method calculates the cost function of the QPNN as introduced at the top of this module. It relies on a</span>
<span class="sd">    training set and will thus throw an error if one has not been provided. Specifically, it includes all</span>
<span class="sd">    input-target pairs for all unit cell operations for all numbers of photons $1 \\leq n \\leq b + 1$,</span>
<span class="sd">    before averaging.</span>

<span class="sd">    Args:</span>
<span class="sd">        phi: $L\\times m(m-1)/2$ phase shifts, $\\phi$, where the ith row contains those for each MZI in the</span>
<span class="sd">            ith layer</span>
<span class="sd">        theta: $L\\times m(m-1)/2$ phase shifts, $\\theta$, where the ith row contains those for each MZI in the</span>
<span class="sd">            ith layer</span>
<span class="sd">        delta: $L\\times m$ phase shifts, $\\delta$, where the ith row contains those for each mode at the output</span>
<span class="sd">            of the mesh in the ith layer</span>

<span class="sd">    Returns:</span>
<span class="sd">        C: cost (i.e. network error) of the QPNN</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check that a training set has been provided</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;No training set was provided for the QPNN.&quot;</span>

    <span class="c1"># construct the QPNN system function in all $N$-dimensional Fock bases for all 1 &lt;= n &lt;= b + 1</span>
    <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">n_photon_succ_rates</span><span class="p">(</span>
        <span class="n">Sn</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">psi_in_n</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">psi_targ_n</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">comp_inds_n</span><span class="p">:</span> <span class="n">jnp_ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp_ndarray</span><span class="p">:</span>
        <span class="nd">@vmap</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">n_photon_unit_cell_succ_rates</span><span class="p">(</span><span class="n">inds</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">jnp_ndarray</span><span class="p">:</span>
            <span class="n">psi_out_n</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psi</span><span class="p">:</span> <span class="n">Sn</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">inds</span><span class="p">)]</span> <span class="o">@</span> <span class="n">psi</span><span class="p">)(</span><span class="n">psi_in_n</span><span class="p">)</span>
            <span class="n">succ_uc</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psit</span><span class="p">,</span> <span class="n">psio</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">psit</span><span class="p">),</span> <span class="n">psio</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)(</span><span class="n">psi_targ_n</span><span class="p">,</span> <span class="n">psi_out_n</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">succ_uc</span>

        <span class="n">succ_rates</span> <span class="o">=</span> <span class="n">n_photon_unit_cell_succ_rates</span><span class="p">(</span><span class="n">comp_inds_n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">succ_rates</span><span class="p">)</span>

    <span class="c1"># compute the success rates for each 1 &lt;= n &lt;= b + 1</span>
    <span class="n">succ_rates</span> <span class="o">=</span> <span class="n">tree_map</span><span class="p">(</span><span class="n">n_photon_succ_rates</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi_in</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi_targ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp_indices</span><span class="p">)</span>

    <span class="c1"># put everything together, take the mean, then calculate cost</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">succ_rates</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">cost</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>






<div class="doc doc-object doc-function">


<h3 id="quotonic.qpnn.TreeQPNN.calc_overall_performance_measures" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">calc_overall_performance_measures</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span></code>

<a href="#quotonic.qpnn.TreeQPNN.calc_overall_performance_measures" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Calculate the overall fidelity, success rate and logical rate of the QPNN.</p>
<p>This method calculates the fidelity, success rate, and logical rate of the QPNN as introduced at the top of
this module. It relies on a training set and will thus throw an error if one has not been provided.
Specifically, it includes all input-target pairs for all unit cell operations for all numbers of photons <span class="arithmatex">\(1
\leq n \leq b + 1\)</span>, before averaging.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>phi</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> phase shifts, <span class="arithmatex">\(\phi\)</span>, where the ith row contains those for each MZI in the
ith layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>theta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> phase shifts, <span class="arithmatex">\(\theta\)</span>, where the ith row contains those for each MZI in the
ith layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>delta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m\)</span> phase shifts, <span class="arithmatex">\(\delta\)</span>, where the ith row contains those for each mode at the output
of the mesh in the ith layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>fid</code></td>            <td>
                  <code><span title="jax.typing.DTypeLike">DTypeLike</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>overall fidelity of the QPNN</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>succ_rate</code></td>            <td>
                  <code><span title="jax.typing.DTypeLike">DTypeLike</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>overall success rate of the QPNN</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>logi_rate</code></td>            <td>
                  <code><span title="jax.typing.DTypeLike">DTypeLike</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>overall logical rate of the QPNN</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/qpnn.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">923</span>
<span class="normal">924</span>
<span class="normal">925</span>
<span class="normal">926</span>
<span class="normal">927</span>
<span class="normal">928</span>
<span class="normal">929</span>
<span class="normal">930</span>
<span class="normal">931</span>
<span class="normal">932</span>
<span class="normal">933</span>
<span class="normal">934</span>
<span class="normal">935</span>
<span class="normal">936</span>
<span class="normal">937</span>
<span class="normal">938</span>
<span class="normal">939</span>
<span class="normal">940</span>
<span class="normal">941</span>
<span class="normal">942</span>
<span class="normal">943</span>
<span class="normal">944</span>
<span class="normal">945</span>
<span class="normal">946</span>
<span class="normal">947</span>
<span class="normal">948</span>
<span class="normal">949</span>
<span class="normal">950</span>
<span class="normal">951</span>
<span class="normal">952</span>
<span class="normal">953</span>
<span class="normal">954</span>
<span class="normal">955</span>
<span class="normal">956</span>
<span class="normal">957</span>
<span class="normal">958</span>
<span class="normal">959</span>
<span class="normal">960</span>
<span class="normal">961</span>
<span class="normal">962</span>
<span class="normal">963</span>
<span class="normal">964</span>
<span class="normal">965</span>
<span class="normal">966</span>
<span class="normal">967</span>
<span class="normal">968</span>
<span class="normal">969</span>
<span class="normal">970</span>
<span class="normal">971</span>
<span class="normal">972</span>
<span class="normal">973</span>
<span class="normal">974</span>
<span class="normal">975</span>
<span class="normal">976</span>
<span class="normal">977</span>
<span class="normal">978</span>
<span class="normal">979</span>
<span class="normal">980</span>
<span class="normal">981</span>
<span class="normal">982</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
<span class="k">def</span><span class="w"> </span><span class="nf">calc_overall_performance_measures</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">DTypeLike</span><span class="p">,</span> <span class="n">DTypeLike</span><span class="p">,</span> <span class="n">DTypeLike</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the overall fidelity, success rate and logical rate of the QPNN.</span>

<span class="sd">    This method calculates the fidelity, success rate, and logical rate of the QPNN as introduced at the top of</span>
<span class="sd">    this module. It relies on a training set and will thus throw an error if one has not been provided.</span>
<span class="sd">    Specifically, it includes all input-target pairs for all unit cell operations for all numbers of photons $1</span>
<span class="sd">    \\leq n \\leq b + 1$, before averaging.</span>

<span class="sd">    Args:</span>
<span class="sd">        phi: $L\\times m(m-1)/2$ phase shifts, $\\phi$, where the ith row contains those for each MZI in the</span>
<span class="sd">            ith layer</span>
<span class="sd">        theta: $L\\times m(m-1)/2$ phase shifts, $\\theta$, where the ith row contains those for each MZI in the</span>
<span class="sd">            ith layer</span>
<span class="sd">        delta: $L\\times m$ phase shifts, $\\delta$, where the ith row contains those for each mode at the output</span>
<span class="sd">            of the mesh in the ith layer</span>

<span class="sd">    Returns:</span>
<span class="sd">        fid: overall fidelity of the QPNN</span>
<span class="sd">        succ_rate: overall success rate of the QPNN</span>
<span class="sd">        logi_rate: overall logical rate of the QPNN</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check that a training set has been provided</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;No training set was provided for the QPNN.&quot;</span>

    <span class="c1"># construct the QPNN system function in all $N$-dimensional Fock bases for all 1 &lt;= n &lt;= b + 1</span>
    <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">measures</span><span class="p">(</span>
        <span class="n">Sn</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">psi_in_n</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">psi_targ_n</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">comp_inds_n</span><span class="p">:</span> <span class="n">jnp_ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="nd">@vmap</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">measures_per_unit_cell</span><span class="p">(</span><span class="n">inds</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="n">psi_out_n</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psi</span><span class="p">:</span> <span class="n">Sn</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">inds</span><span class="p">)]</span> <span class="o">@</span> <span class="n">psi</span><span class="p">)(</span><span class="n">psi_in_n</span><span class="p">)</span>
            <span class="n">succ</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psit</span><span class="p">,</span> <span class="n">psio</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">psit</span><span class="p">),</span> <span class="n">psio</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)(</span><span class="n">psi_targ_n</span><span class="p">,</span> <span class="n">psi_out_n</span><span class="p">)</span>
            <span class="n">logi</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psio</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">psio</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))(</span><span class="n">psi_out_n</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">succ</span><span class="p">,</span> <span class="n">logi</span>

        <span class="n">succ_rates</span><span class="p">,</span> <span class="n">logi_rates</span> <span class="o">=</span> <span class="n">measures_per_unit_cell</span><span class="p">(</span><span class="n">comp_inds_n</span><span class="p">)</span>
        <span class="n">fids</span> <span class="o">=</span> <span class="n">succ_rates</span> <span class="o">/</span> <span class="n">logi_rates</span>
        <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">fids</span><span class="p">),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">succ_rates</span><span class="p">),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">logi_rates</span><span class="p">)</span>

    <span class="c1"># map through the different numbers of photons and unit cell operations, evaluating performance on the way</span>
    <span class="n">meas</span> <span class="o">=</span> <span class="n">tree_map</span><span class="p">(</span><span class="n">measures</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi_in</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi_targ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp_indices</span><span class="p">)</span>
    <span class="n">meas_T</span> <span class="o">=</span> <span class="n">tree_transpose</span><span class="p">(</span>
        <span class="n">outer_treedef</span><span class="o">=</span><span class="n">tree_structure</span><span class="p">(</span><span class="n">S</span><span class="p">),</span>
        <span class="n">inner_treedef</span><span class="o">=</span><span class="n">tree_structure</span><span class="p">(</span><span class="n">meas</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
        <span class="n">pytree_to_transpose</span><span class="o">=</span><span class="n">meas</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">fids</span><span class="p">,</span> <span class="n">succ_rates</span><span class="p">,</span> <span class="n">logi_rates</span> <span class="o">=</span> <span class="n">meas_T</span>

    <span class="c1"># compute the overall fidelity, success rate &amp; logical rate, including all operations in the mean</span>
    <span class="n">fid</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">fids</span><span class="p">))</span>
    <span class="n">succ_rate</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">succ_rates</span><span class="p">))</span>
    <span class="n">logi_rate</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">logi_rates</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">fid</span><span class="p">,</span> <span class="n">succ_rate</span><span class="p">,</span> <span class="n">logi_rate</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>






<div class="doc doc-object doc-function">


<h3 id="quotonic.qpnn.TreeQPNN.calc_unit_cell_performance_measures" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">calc_unit_cell_performance_measures</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span></code>

<a href="#quotonic.qpnn.TreeQPNN.calc_unit_cell_performance_measures" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Calculate the fidelities, success rates and logical rates of the QPNN for each individual unit cell
operation required for tree formation.</p>
<p>This method calculates the fidelity, success rate, and logical rate of the QPNN as introduced at the top of
this module. It relies on a training set and will thus throw an error if one has not been provided.
Specifically, each returned value includes only the input-target pairs for a specific unit cell operation.
For each measure, a tuple is returned. The elements of this tuple are arrays, each for a specific number of
photons in increasing order for all <span class="arithmatex">\(1 \leq n \leq b + 1\)</span>. There may be multiple unit cell operations
required for a given <span class="arithmatex">\(n\)</span>, so these arrays may contain multiple values. The specific dimensions depend in a
complicated way on <span class="arithmatex">\(b\)</span>, which is why they are not provided here in general.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>phi</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> phase shifts, <span class="arithmatex">\(\phi\)</span>, where the ith row contains those for each MZI in the
ith layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>theta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> phase shifts, <span class="arithmatex">\(\theta\)</span>, where the ith row contains those for each MZI in the
ith layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>delta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m\)</span> phase shifts, <span class="arithmatex">\(\delta\)</span>, where the ith row contains those for each mode at the output
of the mesh in the ith layer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>fids</code></td>            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple containing the fidelities of the QPNN for each unit cell operation and each <span class="arithmatex">\(n\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>succ_rates</code></td>            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple containing the success rates of the QPNN for each unit cell operation and each <span class="arithmatex">\(n\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>logi_rates</code></td>            <td>
                  <code><span title="tuple">tuple</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple containing the logical rates of the QPNN for each unit cell operation and each <span class="arithmatex">\(n\)</span></p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/qpnn.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 984</span>
<span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
<span class="k">def</span><span class="w"> </span><span class="nf">calc_unit_cell_performance_measures</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the fidelities, success rates and logical rates of the QPNN for each individual unit cell</span>
<span class="sd">    operation required for tree formation.</span>

<span class="sd">    This method calculates the fidelity, success rate, and logical rate of the QPNN as introduced at the top of</span>
<span class="sd">    this module. It relies on a training set and will thus throw an error if one has not been provided.</span>
<span class="sd">    Specifically, each returned value includes only the input-target pairs for a specific unit cell operation.</span>
<span class="sd">    For each measure, a tuple is returned. The elements of this tuple are arrays, each for a specific number of</span>
<span class="sd">    photons in increasing order for all $1 \\leq n \\leq b + 1$. There may be multiple unit cell operations</span>
<span class="sd">    required for a given $n$, so these arrays may contain multiple values. The specific dimensions depend in a</span>
<span class="sd">    complicated way on $b$, which is why they are not provided here in general.</span>

<span class="sd">    Args:</span>
<span class="sd">        phi: $L\\times m(m-1)/2$ phase shifts, $\\phi$, where the ith row contains those for each MZI in the</span>
<span class="sd">            ith layer</span>
<span class="sd">        theta: $L\\times m(m-1)/2$ phase shifts, $\\theta$, where the ith row contains those for each MZI in the</span>
<span class="sd">            ith layer</span>
<span class="sd">        delta: $L\\times m$ phase shifts, $\\delta$, where the ith row contains those for each mode at the output</span>
<span class="sd">            of the mesh in the ith layer</span>

<span class="sd">    Returns:</span>
<span class="sd">        fids: tuple containing the fidelities of the QPNN for each unit cell operation and each $n$</span>
<span class="sd">        succ_rates: tuple containing the success rates of the QPNN for each unit cell operation and each $n$</span>
<span class="sd">        logi_rates: tuple containing the logical rates of the QPNN for each unit cell operation and each $n$</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># check that a training set has been provided</span>
    <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;No training set was provided for the QPNN.&quot;</span>

    <span class="c1"># construct the QPNN system function in all $N$-dimensional Fock bases for all 1 &lt;= n &lt;= b + 1</span>
    <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">measures</span><span class="p">(</span>
        <span class="n">Sn</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">psi_in_n</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">psi_targ_n</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">comp_inds_n</span><span class="p">:</span> <span class="n">jnp_ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
        <span class="nd">@vmap</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">measures_per_unit_cell</span><span class="p">(</span><span class="n">inds</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="n">psi_out_n</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psi</span><span class="p">:</span> <span class="n">Sn</span><span class="p">[</span><span class="n">jnp</span><span class="o">.</span><span class="n">ix_</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">inds</span><span class="p">)]</span> <span class="o">@</span> <span class="n">psi</span><span class="p">)(</span><span class="n">psi_in_n</span><span class="p">)</span>
            <span class="n">succ_uc</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psit</span><span class="p">,</span> <span class="n">psio</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">psit</span><span class="p">),</span> <span class="n">psio</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)(</span><span class="n">psi_targ_n</span><span class="p">,</span> <span class="n">psi_out_n</span><span class="p">)</span>
            <span class="n">logi_uc</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">psio</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">psio</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))(</span><span class="n">psi_out_n</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">succ_uc</span><span class="p">,</span> <span class="n">logi_uc</span>

        <span class="n">succ_rates</span><span class="p">,</span> <span class="n">logi_rates</span> <span class="o">=</span> <span class="n">measures_per_unit_cell</span><span class="p">(</span><span class="n">comp_inds_n</span><span class="p">)</span>
        <span class="n">succ_rate</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">succ</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">succ</span><span class="p">))(</span><span class="n">succ_rates</span><span class="p">)</span>
        <span class="n">logi_rate</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">logi</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">logi</span><span class="p">))(</span><span class="n">logi_rates</span><span class="p">)</span>
        <span class="n">fid</span> <span class="o">=</span> <span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">succ</span><span class="p">,</span> <span class="n">logi</span><span class="p">:</span> <span class="n">jnp</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">succ</span> <span class="o">/</span> <span class="n">logi</span><span class="p">))(</span><span class="n">succ_rates</span><span class="p">,</span> <span class="n">logi_rates</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fid</span><span class="p">,</span> <span class="n">succ_rate</span><span class="p">,</span> <span class="n">logi_rate</span>

    <span class="c1"># map through the different numbers of photons and unit cell operations, evaluating performance on the way</span>
    <span class="n">meas</span> <span class="o">=</span> <span class="n">tree_map</span><span class="p">(</span><span class="n">measures</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi_in</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi_targ</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp_indices</span><span class="p">)</span>
    <span class="n">meas_T</span> <span class="o">=</span> <span class="n">tree_transpose</span><span class="p">(</span>
        <span class="n">outer_treedef</span><span class="o">=</span><span class="n">tree_structure</span><span class="p">(</span><span class="n">S</span><span class="p">),</span>
        <span class="n">inner_treedef</span><span class="o">=</span><span class="n">tree_structure</span><span class="p">(</span><span class="n">meas</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
        <span class="n">pytree_to_transpose</span><span class="o">=</span><span class="n">meas</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">fids</span><span class="p">,</span> <span class="n">succ_rates</span><span class="p">,</span> <span class="n">logi_rates</span> <span class="o">=</span> <span class="n">meas_T</span>

    <span class="k">return</span> <span class="n">fids</span><span class="p">,</span> <span class="n">succ_rates</span><span class="p">,</span> <span class="n">logi_rates</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>




  </div>

    </div>

</div>




  </div>

    </div>

</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Maintained by <a href="https://www.linkedin.com/in/jacobewaniuk/">Jacob Ewaniuk</a>.
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        
<div class="md-social">
  
    
    
    
    
      
      
    
    <a href="https://github.com/jewaniuk/quotonic" target="_blank" rel="noopener" title="github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
    </a>
  
    
    
    
    
      
      
    
    <a href="https://pypi.org/project/quotonic" target="_blank" rel="noopener" title="pypi.org" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.8 200.5c-7.7-30.9-22.3-54.2-53.4-54.2h-40.1v47.4c0 36.8-31.2 67.8-66.8 67.8H172.7c-29.2 0-53.4 25-53.4 54.3v101.8c0 29 25.2 46 53.4 54.3 33.8 9.9 66.3 11.7 106.8 0 26.9-7.8 53.4-23.5 53.4-54.3v-40.7H226.2v-13.6h160.2c31.1 0 42.6-21.7 53.4-54.2 11.2-33.5 10.7-65.7 0-108.6M286.2 444.7a20.4 20.4 0 1 1 0-40.7 20.4 20.4 0 1 1 0 40.7M167.8 248.1h106.8c29.7 0 53.4-24.5 53.4-54.3V91.9c0-29-24.4-50.7-53.4-55.6-35.8-5.9-74.7-5.6-106.8.1-45.2 8-53.4 24.7-53.4 55.6v40.7h106.9v13.6h-147c-31.1 0-58.3 18.7-66.8 54.2-9.8 40.7-10.2 66.1 0 108.6 7.6 31.6 25.7 54.2 56.8 54.2H101v-48.8c0-35.3 30.5-66.4 66.8-66.4m-6.6-183.4a20.4 20.4 0 1 1 0 40.8 20.4 20.4 0 1 1 0-40.8"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": ["navigation.sections", "navigation.tracking", "toc.integrate", "navigation.instant", "navigation.top", "navigation.tabs", "navigation.prune"], "search": "../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"provider": "mike"}}</script>
    
    
      <script src="../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
        <script src="../js/katex.js"></script>
      
        <script src="https://unpkg.com/katex@0/dist/katex.min.js"></script>
      
        <script src="https://unpkg.com/katex@0/dist/contrib/auto-render.min.js"></script>
      
    
  </body>
</html>