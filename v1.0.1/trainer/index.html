
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
        <meta name="description" content="A platform for performing efficient simulations of nonlinear quantum photonic circuits.">
      
      
        <meta name="author" content="Jacob Ewaniuk">
      
      
        <link rel="canonical" href="https://jewaniuk.github.io/quotonic/v1.0.1/trainer/">
      
      
        <link rel="prev" href="../qpnn/">
      
      
        <link rel="next" href="../training_sets/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.22">
    
    
      
        <title>trainer - quotonic</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.84d31ad4.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../assets/_mkdocstrings.css">
    
      <link rel="stylesheet" href="https://unpkg.com/katex@0/dist/katex.min.css">
    
      <link rel="stylesheet" href="../styles/extra.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent="custom">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#quotonic.trainer.Trainer" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <div data-md-color-scheme="default" data-md-component="outdated" hidden>
        
      </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="quotonic" class="md-header__button md-logo" aria-label="quotonic" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            quotonic
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              trainer
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="white" data-md-color-accent="custom"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="black" data-md-color-accent="custom"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
    
      <div class="md-header__source">
        <a href="https://github.com/jewaniuk/quotonic" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    jewaniuk/quotonic
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="Tabs" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../fock/" class="md-tabs__link">
        
  
  
    
  
  fock

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../clements/" class="md-tabs__link">
        
  
  
    
  
  clements

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../aa/" class="md-tabs__link">
        
  
  
    
  
  aa

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../nl/" class="md-tabs__link">
        
  
  
    
  
  nl

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../qpnn/" class="md-tabs__link">
        
  
  
    
  
  qpnn

      </a>
    </li>
  

      
        
  
  
  
    
  
  
    <li class="md-tabs__item md-tabs__item--active">
      <a href="./" class="md-tabs__link">
        
  
  
    
  
  trainer

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../training_sets/" class="md-tabs__link">
        
  
  
    
  
  training_sets

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../perm/" class="md-tabs__link">
        
  
  
    
  
  perm

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../logic/" class="md-tabs__link">
        
  
  
    
  
  logic

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../utils/" class="md-tabs__link">
        
  
  
    
  
  utils

      </a>
    </li>
  

      
        
  
  
  
  
    <li class="md-tabs__item">
      <a href="../types/" class="md-tabs__link">
        
  
  
    
  
  types

      </a>
    </li>
  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


  

<nav class="md-nav md-nav--primary md-nav--lifted md-nav--integrated" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="quotonic" class="md-nav__button md-logo" aria-label="quotonic" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    quotonic
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/jewaniuk/quotonic" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
  </div>
  <div class="md-source__repository">
    jewaniuk/quotonic
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../fock/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    fock
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../clements/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    clements
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../aa/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    aa
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../nl/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    nl
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../qpnn/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    qpnn
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    trainer
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    trainer
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#quotonic.trainer.Trainer" class="md-nav__link">
    <span class="md-ellipsis">
      Trainer
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Trainer">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#quotonic.trainer.Trainer.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.trainer.Trainer.initialize_params" class="md-nav__link">
    <span class="md-ellipsis">
      initialize_params
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#quotonic.trainer.IdealTrainer" class="md-nav__link">
    <span class="md-ellipsis">
      IdealTrainer
    </span>
  </a>
  
    <nav class="md-nav" aria-label="IdealTrainer">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#quotonic.trainer.IdealTrainer.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.trainer.IdealTrainer.cost" class="md-nav__link">
    <span class="md-ellipsis">
      cost
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.trainer.IdealTrainer.update" class="md-nav__link">
    <span class="md-ellipsis">
      update
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.trainer.IdealTrainer.train" class="md-nav__link">
    <span class="md-ellipsis">
      train
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#quotonic.trainer.ImperfectTrainer" class="md-nav__link">
    <span class="md-ellipsis">
      ImperfectTrainer
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ImperfectTrainer">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#quotonic.trainer.ImperfectTrainer.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.trainer.ImperfectTrainer.cost" class="md-nav__link">
    <span class="md-ellipsis">
      cost
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.trainer.ImperfectTrainer.update" class="md-nav__link">
    <span class="md-ellipsis">
      update
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.trainer.ImperfectTrainer.train" class="md-nav__link">
    <span class="md-ellipsis">
      train
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#quotonic.trainer.TreeTrainer" class="md-nav__link">
    <span class="md-ellipsis">
      TreeTrainer
    </span>
  </a>
  
    <nav class="md-nav" aria-label="TreeTrainer">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#quotonic.trainer.TreeTrainer.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.trainer.TreeTrainer.cost" class="md-nav__link">
    <span class="md-ellipsis">
      cost
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.trainer.TreeTrainer.update" class="md-nav__link">
    <span class="md-ellipsis">
      update
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#quotonic.trainer.TreeTrainer.train" class="md-nav__link">
    <span class="md-ellipsis">
      train
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../training_sets/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    training_sets
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../perm/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    perm
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../logic/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    logic
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../utils/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    utils
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../types/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    types
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


  <h1>trainer</h1>

<div class="doc doc-object doc-module">




    <div class="doc doc-contents first">

        <p>The <code>quotonic.trainer</code> module includes classes that contain methods required to train the respective quantum photonic
neural network (QPNN) models defined in <a href="../qpnn/">qpnn</a>. <code>Trainer</code> serves as a template class and thus includes
attributes and methods that are relevant to training any model. The other trainer classes inherit <code>Trainer</code> and build
from it, yet remain organized similarly to each other in many ways, as will be discussed further below.</p>
<p>When training a QPNN, the goal is to minimize the network cost function by adjusting the variational phase shift
parameters throughout the network architecture. Since most functionalities in <code>quotonic</code> are written for use with
<code>jax</code>, we naturally turn to the version of <code>autograd</code> native to jax for gradient computation, and manage optimization
trials using <code>optax</code>. Currently, we typically apply the default <a href="https://arxiv.org/abs/1412.6980">Adam optimizer</a> and
exponential decay scheduler from <code>optax</code>, as inspired by <a href="https://github.com/JasvithBasani/CasOptAx">Cascaded Optical Systems Approach to Neural Networks
(CasOptAx)</a> as originally designed for use in <a href="https://doi.org/10.1038/s41534-025-01096-9">J. R. Basani <em>et al</em>.,
"Universal logical quantum photonic neural network processor via cavity-assisted interactions", <em>npj Quantum Inf</em>
<strong>11</strong>, 142 (2025)</a>.</p>
<p>When performing a QPNN training simulation, we typically attempt to train network models in a set number of
optimization trials, each proceeding for a set number of training epochs. Each optimization trial
begins by  selecting random linear unitary transformations from the Haar measure, for each layer, and performing
Clements  decomposition (see <a href="../clements/">clements</a>) to extract the initial phase shift parameters. This has been
shown in <a href="https://doi.org/10.1103/PhysRevApplied.11.064044">S. Pai <em>et al</em>., "Matrix Optimization on Universal Unitary Photonic Devices", <em>Phys. Rev. Appl.</em> <strong>11</strong>,
064044 (2019)</a> to improve convergence speed. From the initial
parameters, the cost function can be evaluated, its gradients computed, and the results used to iteratively update
the parameters each epoch (see <code>update</code> method in each class). At the end, the results of each trial are saved to a
dictionary which is returned upon the completion of all trials (see <code>train</code> method in each class).</p>
<p>If you decide to use <code>quotonic</code> to perform research on QPNNs, feel free to develop a trainer class to go with your
QPNN model. Also, we'd be happy to add it if it fits the format appropriately, so please reach out!</p>










  <div class="doc doc-children">































<div class="doc doc-object doc-class">



<h2 id="quotonic.trainer.Trainer" class="doc doc-heading">
            <code>Trainer</code>


<a href="#quotonic.trainer.Trainer" class="headerlink" title="Permanent link">&para;</a></h2>


    <div class="doc doc-contents ">


        <p>Base class for a quantum photonic neural network (QPNN) trainer.</p>
<p>This is effectively a template that prepares the fundamental attributes and methods for any QPNN trainer. Each
trainer is designed to run a set number of optimization trials, each proceeding for a set number of epochs,
with the option to print updates in a chosen interval of epochs. Also, each optimization trial will require a
starting point, and the <code>initialize_params</code> method uses the provided <code>Mesh</code> instance upon initialization to help
prepare these initial guesses easily.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.trainer.Trainer.num_trials">num_trials</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of training trials to run</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.trainer.Trainer.num_epochs">num_epochs</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of training epochs to run</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.trainer.Trainer.print_every">print_every</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>specifies how often results should be printed, in terms of epochs</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.trainer.Trainer.mesh">mesh</span></code></td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="Mesh (quotonic.clements.Mesh)" href="../clements/#quotonic.clements.Mesh">Mesh</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>object containing methods that allow linear layers (i.e. rectangular Mach-Zehnder interferometer
meshes) to be encoded and decoded, passed up from child class, otherwise defaults to a 4-mode mesh</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>








              <details class="quote">
                <summary>Source code in <code>src/quotonic/trainer.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Trainer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for a quantum photonic neural network (QPNN) trainer.</span>

<span class="sd">    This is effectively a template that prepares the fundamental attributes and methods for any QPNN trainer. Each</span>
<span class="sd">    trainer is designed to run a set number of optimization trials, each proceeding for a set number of epochs,</span>
<span class="sd">    with the option to print updates in a chosen interval of epochs. Also, each optimization trial will require a</span>
<span class="sd">    starting point, and the `initialize_params` method uses the provided `Mesh` instance upon initialization to help</span>
<span class="sd">    prepare these initial guesses easily.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        num_trials (int): number of training trials to run</span>
<span class="sd">        num_epochs (int): number of training epochs to run</span>
<span class="sd">        print_every (int): specifies how often results should be printed, in terms of epochs</span>
<span class="sd">        mesh (Mesh): object containing methods that allow linear layers (i.e. rectangular Mach-Zehnder interferometer</span>
<span class="sd">            meshes) to be encoded and decoded, passed up from child class, otherwise defaults to a 4-mode mesh</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_trials</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_epochs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">print_every</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">mesh</span><span class="p">:</span> <span class="n">Mesh</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialization of a Trainer instance.</span>

<span class="sd">        Args:</span>
<span class="sd">            num_trials: number of training trials to run</span>
<span class="sd">            num_epochs: number of training epochs to run</span>
<span class="sd">            print_every: specifies how often results should be printed, in terms of epochs</span>
<span class="sd">            mesh: object containing methods that allow linear layers (i.e. rectangular Mach-Zehnder interferometer</span>
<span class="sd">                meshes) to be encoded and decoded</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># store the provided properties of the Trainer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span> <span class="o">=</span> <span class="n">num_trials</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span> <span class="o">=</span> <span class="n">num_epochs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print_every</span> <span class="o">=</span> <span class="n">print_every</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span> <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">Mesh</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">initialize_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">jnp_ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the phase shift parameters of a QPNN randomly.</span>

<span class="sd">        See the training description at the top of this module for more details. Here, $L$ is the number of layers in</span>
<span class="sd">        the QPNN and $m$ is the number of optical modes.</span>

<span class="sd">        Args:</span>
<span class="sd">            L: number of layers in the QPNN</span>

<span class="sd">        Returns:</span>
<span class="sd">            phi: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\phi}$, for all MZIs in each of the $L$</span>
<span class="sd">                meshes in the QPNN</span>
<span class="sd">            theta: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\theta}$, for all MZIs in each of the $L$</span>
<span class="sd">                meshes in the QPNN</span>
<span class="sd">            delta: $L\\times m$ array of phase shifts, $\\boldsymbol{\\delta}$, applied in each mode at the output of</span>
<span class="sd">                each of the $L$ meshes in the QPNN</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># generate a random unitary from the Haar measure for each layer, and perform Clements decomposition</span>
        <span class="c1"># to extract the corresponding random phases</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">m</span>
        <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">L</span><span class="p">,</span> <span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">L</span><span class="p">,</span> <span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">L</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">genHaarUnitary</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-function">


<h3 id="quotonic.trainer.Trainer.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">num_trials</span><span class="p">,</span> <span class="n">num_epochs</span><span class="p">,</span> <span class="n">print_every</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

<a href="#quotonic.trainer.Trainer.__init__" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Initialization of a Trainer instance.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>num_trials</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of training trials to run</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>num_epochs</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of training epochs to run</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>print_every</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>specifies how often results should be printed, in terms of epochs</p>
              </div>
            </td>
            <td>
                  <code>10</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>mesh</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="Mesh (quotonic.clements.Mesh)" href="../clements/#quotonic.clements.Mesh">Mesh</a> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>object containing methods that allow linear layers (i.e. rectangular Mach-Zehnder interferometer
meshes) to be encoded and decoded</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/trainer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_trials</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">num_epochs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">print_every</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">mesh</span><span class="p">:</span> <span class="n">Mesh</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialization of a Trainer instance.</span>

<span class="sd">    Args:</span>
<span class="sd">        num_trials: number of training trials to run</span>
<span class="sd">        num_epochs: number of training epochs to run</span>
<span class="sd">        print_every: specifies how often results should be printed, in terms of epochs</span>
<span class="sd">        mesh: object containing methods that allow linear layers (i.e. rectangular Mach-Zehnder interferometer</span>
<span class="sd">            meshes) to be encoded and decoded</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># store the provided properties of the Trainer</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span> <span class="o">=</span> <span class="n">num_trials</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span> <span class="o">=</span> <span class="n">num_epochs</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">print_every</span> <span class="o">=</span> <span class="n">print_every</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh</span> <span class="k">if</span> <span class="n">mesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">Mesh</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>






<div class="doc doc-object doc-function">


<h3 id="quotonic.trainer.Trainer.initialize_params" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">initialize_params</span><span class="p">(</span><span class="n">L</span><span class="p">)</span></code>

<a href="#quotonic.trainer.Trainer.initialize_params" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Initialize the phase shift parameters of a QPNN randomly.</p>
<p>See the training description at the top of this module for more details. Here, <span class="arithmatex">\(L\)</span> is the number of layers in
the QPNN and <span class="arithmatex">\(m\)</span> is the number of optical modes.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>L</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of layers in the QPNN</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>phi</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> array of phase shifts, <span class="arithmatex">\(\boldsymbol{\phi}\)</span>, for all MZIs in each of the <span class="arithmatex">\(L\)</span>
meshes in the QPNN</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>theta</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> array of phase shifts, <span class="arithmatex">\(\boldsymbol{\theta}\)</span>, for all MZIs in each of the <span class="arithmatex">\(L\)</span>
meshes in the QPNN</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>delta</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m\)</span> array of phase shifts, <span class="arithmatex">\(\boldsymbol{\delta}\)</span>, applied in each mode at the output of
each of the <span class="arithmatex">\(L\)</span> meshes in the QPNN</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/trainer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">initialize_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">L</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">jnp_ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize the phase shift parameters of a QPNN randomly.</span>

<span class="sd">    See the training description at the top of this module for more details. Here, $L$ is the number of layers in</span>
<span class="sd">    the QPNN and $m$ is the number of optical modes.</span>

<span class="sd">    Args:</span>
<span class="sd">        L: number of layers in the QPNN</span>

<span class="sd">    Returns:</span>
<span class="sd">        phi: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\phi}$, for all MZIs in each of the $L$</span>
<span class="sd">            meshes in the QPNN</span>
<span class="sd">        theta: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\theta}$, for all MZIs in each of the $L$</span>
<span class="sd">            meshes in the QPNN</span>
<span class="sd">        delta: $L\\times m$ array of phase shifts, $\\boldsymbol{\\delta}$, applied in each mode at the output of</span>
<span class="sd">            each of the $L$ meshes in the QPNN</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># generate a random unitary from the Haar measure for each layer, and perform Clements decomposition</span>
    <span class="c1"># to extract the corresponding random phases</span>
    <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">m</span>
    <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">L</span><span class="p">,</span> <span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">L</span><span class="p">,</span> <span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">L</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
        <span class="n">U</span> <span class="o">=</span> <span class="n">genHaarUnitary</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="n">phi</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">theta</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">U</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">jnp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>




  </div>

    </div>

</div>






<div class="doc doc-object doc-class">



<h2 id="quotonic.trainer.IdealTrainer" class="doc doc-heading">
            <code>IdealTrainer</code>


<a href="#quotonic.trainer.IdealTrainer" class="headerlink" title="Permanent link">&para;</a></h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="Trainer (quotonic.trainer.Trainer)" href="#quotonic.trainer.Trainer">Trainer</a></code></p>


        <p>Class for training idealized QPNNs based on single-site Kerr-like nonlinearities.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.trainer.IdealTrainer.num_trials">num_trials</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of training trials to run</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.trainer.IdealTrainer.num_epochs">num_epochs</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of training epochs to run</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.trainer.IdealTrainer.print_every">print_every</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>specifies how often results should be printed, in terms of epochs</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.trainer.IdealTrainer.mesh">mesh</span></code></td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="Mesh (quotonic.clements.Mesh)" href="../clements/#quotonic.clements.Mesh">Mesh</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>object containing methods that allow linear layers (i.e. rectangular Mach-Zehnder interferometer
meshes) to be encoded and decoded, taken from IdealQPNN instance</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.trainer.IdealTrainer.qpnn">qpnn</span></code></td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="IdealQPNN (quotonic.qpnn.IdealQPNN)" href="../qpnn/#quotonic.qpnn.IdealQPNN">IdealQPNN</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>object containing methods to construct the transfer function enacted by a QPNN, and compute
the network fidelity</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.trainer.IdealTrainer.sched">sched</span></code></td>
            <td>
                  <code><span title="optax.Schedule">Schedule</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>the exponential decay scheduler used during optimization</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.trainer.IdealTrainer.opt">opt</span></code></td>
            <td>
                  <code><span title="optax.GradientTransformation">GradientTransformation</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>the adam optimizer used during optimization</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>








              <details class="quote">
                <summary>Source code in <code>src/quotonic/trainer.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">IdealTrainer</span><span class="p">(</span><span class="n">Trainer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class for training idealized QPNNs based on single-site Kerr-like nonlinearities.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        num_trials (int): number of training trials to run</span>
<span class="sd">        num_epochs (int): number of training epochs to run</span>
<span class="sd">        print_every (int): specifies how often results should be printed, in terms of epochs</span>
<span class="sd">        mesh (Mesh): object containing methods that allow linear layers (i.e. rectangular Mach-Zehnder interferometer</span>
<span class="sd">            meshes) to be encoded and decoded, taken from IdealQPNN instance</span>
<span class="sd">        qpnn (IdealQPNN): object containing methods to construct the transfer function enacted by a QPNN, and compute</span>
<span class="sd">            the network fidelity</span>
<span class="sd">        sched (optax.Schedule): the exponential decay scheduler used during optimization</span>
<span class="sd">        opt (optax.GradientTransformation): the adam optimizer used during optimization</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">qpnn</span><span class="p">:</span> <span class="n">IdealQPNN</span><span class="p">,</span>
        <span class="n">num_trials</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">num_epochs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">print_every</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">sched0</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.025</span><span class="p">,</span>
        <span class="n">sched_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialization of an Ideal Trainer instance.</span>

<span class="sd">        The exponential decay scheduler and optimizer are initialized here, so desired settings should be passed upon</span>
<span class="sd">        initialization if they differ from the default options.</span>

<span class="sd">        Args:</span>
<span class="sd">            qpnn: object containing methods to construct the transfer function enacted by a QPNN, and compute the</span>
<span class="sd">                network cost function</span>
<span class="sd">            num_trials: number of training trials to run</span>
<span class="sd">            num_epochs: number of training epochs to run</span>
<span class="sd">            print_every: specifies how often results should be printed, in terms of epochs</span>
<span class="sd">            sched0: initial value of the exponential decay scheduler used during optimization</span>
<span class="sd">            sched_rate: decay rate of the exponential decay scheduler used during optimization</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_trials</span><span class="p">,</span> <span class="n">num_epochs</span><span class="p">,</span> <span class="n">print_every</span><span class="o">=</span><span class="n">print_every</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">qpnn</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>

        <span class="c1"># store the provided properties of the Ideal Trainer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span> <span class="o">=</span> <span class="n">qpnn</span>

        <span class="c1"># create the scheduler and optimizer for training</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sched</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">exponential_decay</span><span class="p">(</span><span class="n">init_value</span><span class="o">=</span><span class="n">sched0</span><span class="p">,</span> <span class="n">transition_steps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">,</span> <span class="n">decay_rate</span><span class="o">=</span><span class="n">sched_rate</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opt</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">adam</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sched</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DTypeLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate the cost function that is minimized during training.</span>

<span class="sd">        See `[qpnn](qpnn.md)` for more details on the cost function.</span>

<span class="sd">        Args:</span>
<span class="sd">            phi: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\phi}$, for all MZIs in each of the $L$</span>
<span class="sd">                meshes in the QPNN</span>
<span class="sd">            theta: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\theta}$, for all MZIs in each of the $L$</span>
<span class="sd">                meshes in the QPNN</span>
<span class="sd">            delta: $L\\times m$ array of phase shifts, $\\boldsymbol{\\delta}$, applied in each mode at the output of</span>
<span class="sd">                each of the $L$ meshes in the QPNN</span>

<span class="sd">        Returns:</span>
<span class="sd">            C: cost (i.e. network error) of the QPNN</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">calc_fidelity</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">F</span>  <span class="c1"># type: ignore</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">optstate</span><span class="p">:</span> <span class="n">optax</span><span class="o">.</span><span class="n">OptState</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">DTypeLike</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">jnp_ndarray</span><span class="p">],</span> <span class="n">optax</span><span class="o">.</span><span class="n">OptState</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adjust the variational parameters to minimize the cost function.</span>

<span class="sd">        This method wraps around the `cost` function to evaluate it and its gradients with respect to the variational</span>
<span class="sd">        phase shift parameters. The updates to the parameters are computed using the attribute that stores the</span>
<span class="sd">        optimizer, then applied to the parameters which are subsequently returned alongside the value of the cost</span>
<span class="sd">        function and the state of the optimizer.</span>

<span class="sd">        Args:</span>
<span class="sd">            phi: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\phi}$, for all MZIs in each of the $L$</span>
<span class="sd">                meshes in the QPNN</span>
<span class="sd">            theta: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\theta}$, for all MZIs in each of the $L$</span>
<span class="sd">                meshes in the QPNN</span>
<span class="sd">            delta: $L\\times m$ array of phase shifts, $\\boldsymbol{\\delta}$, applied in each mode at the output of</span>
<span class="sd">                each of the $L$ meshes in the QPNN</span>
<span class="sd">            optstate: current state of the optimizer</span>

<span class="sd">        Returns:</span>
<span class="sd">            C: cost (i.e. network error) of the QPNN</span>
<span class="sd">            Theta: tuple `(phi, theta, delta)` including arrays that store the updated phase shift parameters</span>
<span class="sd">                $(\\boldsymbol{\\phi}, \\boldsymbol{\\theta}, \\boldsymbol{\\delta})$</span>
<span class="sd">            optstate: updated state of the optimizer</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># calculate cost function and its gradient with respect to the 0th, 1st, 2nd parameters,</span>
        <span class="c1"># which are phi, theta, delta respectively</span>
        <span class="n">C</span><span class="p">,</span> <span class="n">grads</span> <span class="o">=</span> <span class="n">value_and_grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cost</span><span class="p">,</span> <span class="n">argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>

        <span class="c1"># calculate updates to the parameters and the state of the optimizer from the gradients, then apply them</span>
        <span class="n">updates</span><span class="p">,</span> <span class="n">optstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="n">optstate</span><span class="p">)</span>
        <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">apply_updates</span><span class="p">((</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">),</span> <span class="n">updates</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">C</span><span class="p">,</span> <span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">),</span> <span class="n">optstate</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Train the QPNN in a number of trials.</span>

<span class="sd">        A dictionary of results is first defined and initialized, then it is iteratively filled by training the given</span>
<span class="sd">        QPNN model in the given number of trials. Each trial, the phase shift parameters are initialized alongside</span>
<span class="sd">        the state of the optimizer, then the parameters are updated iteratively over the given number of epochs.</span>
<span class="sd">        Updates may be printed during training at set intervals of epochs, and at the end of each trial a summary</span>
<span class="sd">        statement is printed as well.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dictionary that contains the relevant results of the training simulation</span>

<span class="sd">                - **&quot;F&quot;** (`np_ndarray`): array of network fidelities at each trial and epoch, with shape `(num_trials,</span>
<span class="sd">                    num_epochs)`</span>
<span class="sd">                - **&quot;phi&quot;** (`np_ndarray`): array of optimized phase shifts $\\boldsymbol{\\phi}$ for all training</span>
<span class="sd">                    trials, with shape `(num_trials, L, m * (m - 1) // 2)`</span>
<span class="sd">                - **&quot;theta&quot;** (`np_ndarray`) array of optimized phase shifts $\\boldsymbol{\\theta}$ for all training</span>
<span class="sd">                    trials, with shape `(num_trials, L, m * (m - 1) // 2)`</span>
<span class="sd">                - **&quot;delta&quot;** (`np_ndarray`) array of optimized phase shifts $\\boldsymbol{\\delta}$ for all training</span>
<span class="sd">                    trials, with shape `(num_trials, L, m)`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># prepare the results dictionary</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;F&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
            <span class="s2">&quot;phi&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
            <span class="s2">&quot;theta&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
            <span class="s2">&quot;delta&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">trial</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Trial: </span><span class="si">{</span><span class="n">trial</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># prepare the initial parameters and initial state of the optimizer</span>
            <span class="n">Theta0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialize_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
            <span class="n">initial_optstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">Theta0</span><span class="p">)</span>

            <span class="c1"># iterate through the epochs, optimizing the parameters at each iteration</span>
            <span class="n">Theta</span> <span class="o">=</span> <span class="n">Theta0</span>
            <span class="n">optstate</span> <span class="o">=</span> <span class="n">initial_optstate</span>
            <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">):</span>
                <span class="n">C</span><span class="p">,</span> <span class="n">Theta</span><span class="p">,</span> <span class="n">optstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="n">Theta</span><span class="p">,</span> <span class="n">optstate</span><span class="p">)</span>
                <span class="n">F</span><span class="p">[</span><span class="n">epoch</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">C</span>  <span class="c1"># type: ignore</span>

                <span class="k">if</span> <span class="n">epoch</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_every</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Epoch: </span><span class="si">{</span><span class="n">epoch</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Cost: </span><span class="si">{</span><span class="n">C</span><span class="si">:</span><span class="s2">.4e</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Fidelity: </span><span class="si">{</span><span class="n">F</span><span class="p">[</span><span class="n">epoch</span><span class="p">]</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;COMPLETE! </span><span class="se">\t</span><span class="s2"> Cost: </span><span class="si">{</span><span class="n">C</span><span class="si">:</span><span class="s2">.4e</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Fidelity: </span><span class="si">{</span><span class="n">F</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># store the results from this trial</span>
            <span class="n">results</span><span class="p">[</span><span class="s2">&quot;F&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span>
            <span class="n">results</span><span class="p">[</span><span class="s2">&quot;phi&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;theta&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;delta&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Theta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="p">]</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-function">


<h3 id="quotonic.trainer.IdealTrainer.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">qpnn</span><span class="p">,</span> <span class="n">num_trials</span><span class="p">,</span> <span class="n">num_epochs</span><span class="p">,</span> <span class="n">print_every</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">sched0</span><span class="o">=</span><span class="mf">0.025</span><span class="p">,</span> <span class="n">sched_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span></code>

<a href="#quotonic.trainer.IdealTrainer.__init__" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Initialization of an Ideal Trainer instance.</p>
<p>The exponential decay scheduler and optimizer are initialized here, so desired settings should be passed upon
initialization if they differ from the default options.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>qpnn</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="IdealQPNN (quotonic.qpnn.IdealQPNN)" href="../qpnn/#quotonic.qpnn.IdealQPNN">IdealQPNN</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>object containing methods to construct the transfer function enacted by a QPNN, and compute the
network cost function</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>num_trials</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of training trials to run</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>num_epochs</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of training epochs to run</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>print_every</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>specifies how often results should be printed, in terms of epochs</p>
              </div>
            </td>
            <td>
                  <code>10</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>sched0</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>initial value of the exponential decay scheduler used during optimization</p>
              </div>
            </td>
            <td>
                  <code>0.025</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>sched_rate</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>decay rate of the exponential decay scheduler used during optimization</p>
              </div>
            </td>
            <td>
                  <code>0.1</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/trainer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">qpnn</span><span class="p">:</span> <span class="n">IdealQPNN</span><span class="p">,</span>
    <span class="n">num_trials</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">num_epochs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">print_every</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">sched0</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.025</span><span class="p">,</span>
    <span class="n">sched_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialization of an Ideal Trainer instance.</span>

<span class="sd">    The exponential decay scheduler and optimizer are initialized here, so desired settings should be passed upon</span>
<span class="sd">    initialization if they differ from the default options.</span>

<span class="sd">    Args:</span>
<span class="sd">        qpnn: object containing methods to construct the transfer function enacted by a QPNN, and compute the</span>
<span class="sd">            network cost function</span>
<span class="sd">        num_trials: number of training trials to run</span>
<span class="sd">        num_epochs: number of training epochs to run</span>
<span class="sd">        print_every: specifies how often results should be printed, in terms of epochs</span>
<span class="sd">        sched0: initial value of the exponential decay scheduler used during optimization</span>
<span class="sd">        sched_rate: decay rate of the exponential decay scheduler used during optimization</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_trials</span><span class="p">,</span> <span class="n">num_epochs</span><span class="p">,</span> <span class="n">print_every</span><span class="o">=</span><span class="n">print_every</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">qpnn</span><span class="o">.</span><span class="n">mesh</span><span class="p">)</span>

    <span class="c1"># store the provided properties of the Ideal Trainer</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span> <span class="o">=</span> <span class="n">qpnn</span>

    <span class="c1"># create the scheduler and optimizer for training</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">sched</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">exponential_decay</span><span class="p">(</span><span class="n">init_value</span><span class="o">=</span><span class="n">sched0</span><span class="p">,</span> <span class="n">transition_steps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">,</span> <span class="n">decay_rate</span><span class="o">=</span><span class="n">sched_rate</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">opt</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">adam</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sched</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>






<div class="doc doc-object doc-function">


<h3 id="quotonic.trainer.IdealTrainer.cost" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">cost</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span></code>

<a href="#quotonic.trainer.IdealTrainer.cost" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Evaluate the cost function that is minimized during training.</p>
<p>See <code>[qpnn](qpnn.md)</code> for more details on the cost function.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>phi</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> array of phase shifts, <span class="arithmatex">\(\boldsymbol{\phi}\)</span>, for all MZIs in each of the <span class="arithmatex">\(L\)</span>
meshes in the QPNN</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>theta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> array of phase shifts, <span class="arithmatex">\(\boldsymbol{\theta}\)</span>, for all MZIs in each of the <span class="arithmatex">\(L\)</span>
meshes in the QPNN</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>delta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m\)</span> array of phase shifts, <span class="arithmatex">\(\boldsymbol{\delta}\)</span>, applied in each mode at the output of
each of the <span class="arithmatex">\(L\)</span> meshes in the QPNN</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>C</code></td>            <td>
                  <code><span title="jax.typing.DTypeLike">DTypeLike</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>cost (i.e. network error) of the QPNN</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/trainer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DTypeLike</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Evaluate the cost function that is minimized during training.</span>

<span class="sd">    See `[qpnn](qpnn.md)` for more details on the cost function.</span>

<span class="sd">    Args:</span>
<span class="sd">        phi: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\phi}$, for all MZIs in each of the $L$</span>
<span class="sd">            meshes in the QPNN</span>
<span class="sd">        theta: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\theta}$, for all MZIs in each of the $L$</span>
<span class="sd">            meshes in the QPNN</span>
<span class="sd">        delta: $L\\times m$ array of phase shifts, $\\boldsymbol{\\delta}$, applied in each mode at the output of</span>
<span class="sd">            each of the $L$ meshes in the QPNN</span>

<span class="sd">    Returns:</span>
<span class="sd">        C: cost (i.e. network error) of the QPNN</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">calc_fidelity</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">F</span>  <span class="c1"># type: ignore</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>






<div class="doc doc-object doc-function">


<h3 id="quotonic.trainer.IdealTrainer.update" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">update</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">optstate</span><span class="p">)</span></code>

<a href="#quotonic.trainer.IdealTrainer.update" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Adjust the variational parameters to minimize the cost function.</p>
<p>This method wraps around the <code>cost</code> function to evaluate it and its gradients with respect to the variational
phase shift parameters. The updates to the parameters are computed using the attribute that stores the
optimizer, then applied to the parameters which are subsequently returned alongside the value of the cost
function and the state of the optimizer.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>phi</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> array of phase shifts, <span class="arithmatex">\(\boldsymbol{\phi}\)</span>, for all MZIs in each of the <span class="arithmatex">\(L\)</span>
meshes in the QPNN</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>theta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> array of phase shifts, <span class="arithmatex">\(\boldsymbol{\theta}\)</span>, for all MZIs in each of the <span class="arithmatex">\(L\)</span>
meshes in the QPNN</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>delta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m\)</span> array of phase shifts, <span class="arithmatex">\(\boldsymbol{\delta}\)</span>, applied in each mode at the output of
each of the <span class="arithmatex">\(L\)</span> meshes in the QPNN</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>optstate</code>
            </td>
            <td>
                  <code><span title="optax.OptState">OptState</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>current state of the optimizer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>C</code></td>            <td>
                  <code><span title="jax.typing.DTypeLike">DTypeLike</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>cost (i.e. network error) of the QPNN</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>Theta</code></td>            <td>
                  <code><span title="tuple">tuple</span>[<a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a>, <a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a>, <a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple <code>(phi, theta, delta)</code> including arrays that store the updated phase shift parameters
<span class="arithmatex">\((\boldsymbol{\phi}, \boldsymbol{\theta}, \boldsymbol{\delta})\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>optstate</code></td>            <td>
                  <code><span title="optax.OptState">OptState</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>updated state of the optimizer</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/trainer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">optstate</span><span class="p">:</span> <span class="n">optax</span><span class="o">.</span><span class="n">OptState</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">DTypeLike</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">jnp_ndarray</span><span class="p">],</span> <span class="n">optax</span><span class="o">.</span><span class="n">OptState</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adjust the variational parameters to minimize the cost function.</span>

<span class="sd">    This method wraps around the `cost` function to evaluate it and its gradients with respect to the variational</span>
<span class="sd">    phase shift parameters. The updates to the parameters are computed using the attribute that stores the</span>
<span class="sd">    optimizer, then applied to the parameters which are subsequently returned alongside the value of the cost</span>
<span class="sd">    function and the state of the optimizer.</span>

<span class="sd">    Args:</span>
<span class="sd">        phi: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\phi}$, for all MZIs in each of the $L$</span>
<span class="sd">            meshes in the QPNN</span>
<span class="sd">        theta: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\theta}$, for all MZIs in each of the $L$</span>
<span class="sd">            meshes in the QPNN</span>
<span class="sd">        delta: $L\\times m$ array of phase shifts, $\\boldsymbol{\\delta}$, applied in each mode at the output of</span>
<span class="sd">            each of the $L$ meshes in the QPNN</span>
<span class="sd">        optstate: current state of the optimizer</span>

<span class="sd">    Returns:</span>
<span class="sd">        C: cost (i.e. network error) of the QPNN</span>
<span class="sd">        Theta: tuple `(phi, theta, delta)` including arrays that store the updated phase shift parameters</span>
<span class="sd">            $(\\boldsymbol{\\phi}, \\boldsymbol{\\theta}, \\boldsymbol{\\delta})$</span>
<span class="sd">        optstate: updated state of the optimizer</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># calculate cost function and its gradient with respect to the 0th, 1st, 2nd parameters,</span>
    <span class="c1"># which are phi, theta, delta respectively</span>
    <span class="n">C</span><span class="p">,</span> <span class="n">grads</span> <span class="o">=</span> <span class="n">value_and_grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cost</span><span class="p">,</span> <span class="n">argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>

    <span class="c1"># calculate updates to the parameters and the state of the optimizer from the gradients, then apply them</span>
    <span class="n">updates</span><span class="p">,</span> <span class="n">optstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="n">optstate</span><span class="p">)</span>
    <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">apply_updates</span><span class="p">((</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">),</span> <span class="n">updates</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">C</span><span class="p">,</span> <span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">),</span> <span class="n">optstate</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>






<div class="doc doc-object doc-function">


<h3 id="quotonic.trainer.IdealTrainer.train" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">train</span><span class="p">()</span></code>

<a href="#quotonic.trainer.IdealTrainer.train" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Train the QPNN in a number of trials.</p>
<p>A dictionary of results is first defined and initialized, then it is iteratively filled by training the given
QPNN model in the given number of trials. Each trial, the phase shift parameters are initialized alongside
the state of the optimizer, then the parameters are updated iteratively over the given number of epochs.
Updates may be printed during training at set intervals of epochs, and at the end of each trial a summary
statement is printed as well.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="dict">dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dictionary that contains the relevant results of the training simulation</p>
<ul>
<li><strong>"F"</strong> (<code>np_ndarray</code>): array of network fidelities at each trial and epoch, with shape <code>(num_trials,
    num_epochs)</code></li>
<li><strong>"phi"</strong> (<code>np_ndarray</code>): array of optimized phase shifts <span class="arithmatex">\(\boldsymbol{\phi}\)</span> for all training
    trials, with shape <code>(num_trials, L, m * (m - 1) // 2)</code></li>
<li><strong>"theta"</strong> (<code>np_ndarray</code>) array of optimized phase shifts <span class="arithmatex">\(\boldsymbol{\theta}\)</span> for all training
    trials, with shape <code>(num_trials, L, m * (m - 1) // 2)</code></li>
<li><strong>"delta"</strong> (<code>np_ndarray</code>) array of optimized phase shifts <span class="arithmatex">\(\boldsymbol{\delta}\)</span> for all training
    trials, with shape <code>(num_trials, L, m)</code></li>
</ul>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/trainer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Train the QPNN in a number of trials.</span>

<span class="sd">    A dictionary of results is first defined and initialized, then it is iteratively filled by training the given</span>
<span class="sd">    QPNN model in the given number of trials. Each trial, the phase shift parameters are initialized alongside</span>
<span class="sd">    the state of the optimizer, then the parameters are updated iteratively over the given number of epochs.</span>
<span class="sd">    Updates may be printed during training at set intervals of epochs, and at the end of each trial a summary</span>
<span class="sd">    statement is printed as well.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dictionary that contains the relevant results of the training simulation</span>

<span class="sd">            - **&quot;F&quot;** (`np_ndarray`): array of network fidelities at each trial and epoch, with shape `(num_trials,</span>
<span class="sd">                num_epochs)`</span>
<span class="sd">            - **&quot;phi&quot;** (`np_ndarray`): array of optimized phase shifts $\\boldsymbol{\\phi}$ for all training</span>
<span class="sd">                trials, with shape `(num_trials, L, m * (m - 1) // 2)`</span>
<span class="sd">            - **&quot;theta&quot;** (`np_ndarray`) array of optimized phase shifts $\\boldsymbol{\\theta}$ for all training</span>
<span class="sd">                trials, with shape `(num_trials, L, m * (m - 1) // 2)`</span>
<span class="sd">            - **&quot;delta&quot;** (`np_ndarray`) array of optimized phase shifts $\\boldsymbol{\\delta}$ for all training</span>
<span class="sd">                trials, with shape `(num_trials, L, m)`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># prepare the results dictionary</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;F&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="s2">&quot;phi&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="s2">&quot;theta&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="s2">&quot;delta&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">trial</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Trial: </span><span class="si">{</span><span class="n">trial</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># prepare the initial parameters and initial state of the optimizer</span>
        <span class="n">Theta0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialize_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
        <span class="n">initial_optstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">Theta0</span><span class="p">)</span>

        <span class="c1"># iterate through the epochs, optimizing the parameters at each iteration</span>
        <span class="n">Theta</span> <span class="o">=</span> <span class="n">Theta0</span>
        <span class="n">optstate</span> <span class="o">=</span> <span class="n">initial_optstate</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">):</span>
            <span class="n">C</span><span class="p">,</span> <span class="n">Theta</span><span class="p">,</span> <span class="n">optstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="n">Theta</span><span class="p">,</span> <span class="n">optstate</span><span class="p">)</span>
            <span class="n">F</span><span class="p">[</span><span class="n">epoch</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">C</span>  <span class="c1"># type: ignore</span>

            <span class="k">if</span> <span class="n">epoch</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_every</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Epoch: </span><span class="si">{</span><span class="n">epoch</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Cost: </span><span class="si">{</span><span class="n">C</span><span class="si">:</span><span class="s2">.4e</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Fidelity: </span><span class="si">{</span><span class="n">F</span><span class="p">[</span><span class="n">epoch</span><span class="p">]</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;COMPLETE! </span><span class="se">\t</span><span class="s2"> Cost: </span><span class="si">{</span><span class="n">C</span><span class="si">:</span><span class="s2">.4e</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Fidelity: </span><span class="si">{</span><span class="n">F</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># store the results from this trial</span>
        <span class="n">results</span><span class="p">[</span><span class="s2">&quot;F&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="n">F</span>
        <span class="n">results</span><span class="p">[</span><span class="s2">&quot;phi&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;theta&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;delta&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Theta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">results</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>




  </div>

    </div>

</div>






<div class="doc doc-object doc-class">



<h2 id="quotonic.trainer.ImperfectTrainer" class="doc doc-heading">
            <code>ImperfectTrainer</code>


<a href="#quotonic.trainer.ImperfectTrainer" class="headerlink" title="Permanent link">&para;</a></h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="Trainer (quotonic.trainer.Trainer)" href="#quotonic.trainer.Trainer">Trainer</a></code></p>


        <p>Class for training imperfect QPNNs based on single-site Kerr-like nonlinearities.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.trainer.ImperfectTrainer.num_trials">num_trials</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of training trials to run</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.trainer.ImperfectTrainer.num_epochs">num_epochs</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of training epochs to run</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.trainer.ImperfectTrainer.print_every">print_every</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>specifies how often results should be printed, in terms of epochs</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.trainer.ImperfectTrainer.mesh">mesh</span></code></td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="Mesh (quotonic.clements.Mesh)" href="../clements/#quotonic.clements.Mesh">Mesh</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>object containing methods that allow linear layers (i.e. rectangular Mach-Zehnder interferometer
meshes) to be encoded and decoded, taken from ImperfectQPNN instance</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.trainer.ImperfectTrainer.qpnn">qpnn</span></code></td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="ImperfectQPNN (quotonic.qpnn.ImperfectQPNN)" href="../qpnn/#quotonic.qpnn.ImperfectQPNN">ImperfectQPNN</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>object containing methods to construct the transfer function enacted by a QPNN, and
compute the network performance measures</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.trainer.ImperfectTrainer.sched">sched</span></code></td>
            <td>
                  <code><span title="optax.Schedule">Schedule</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>the exponential decay scheduler used during optimization</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.trainer.ImperfectTrainer.opt">opt</span></code></td>
            <td>
                  <code><span title="optax.GradientTransformation">GradientTransformation</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>the adam optimizer used during optimization</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>








              <details class="quote">
                <summary>Source code in <code>src/quotonic/trainer.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">ImperfectTrainer</span><span class="p">(</span><span class="n">Trainer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class for training imperfect QPNNs based on single-site Kerr-like nonlinearities.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        num_trials (int): number of training trials to run</span>
<span class="sd">        num_epochs (int): number of training epochs to run</span>
<span class="sd">        print_every (int): specifies how often results should be printed, in terms of epochs</span>
<span class="sd">        mesh (Mesh): object containing methods that allow linear layers (i.e. rectangular Mach-Zehnder interferometer</span>
<span class="sd">            meshes) to be encoded and decoded, taken from ImperfectQPNN instance</span>
<span class="sd">        qpnn (ImperfectQPNN): object containing methods to construct the transfer function enacted by a QPNN, and</span>
<span class="sd">            compute the network performance measures</span>
<span class="sd">        sched (optax.Schedule): the exponential decay scheduler used during optimization</span>
<span class="sd">        opt (optax.GradientTransformation): the adam optimizer used during optimization</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">qpnn</span><span class="p">:</span> <span class="n">ImperfectQPNN</span><span class="p">,</span>
        <span class="n">num_trials</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">num_epochs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">print_every</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">sched0</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.025</span><span class="p">,</span>
        <span class="n">sched_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialization of an Imperfect Trainer instance.</span>

<span class="sd">        The exponential decay scheduler and optimizer are initialized here, so desired settings should be passed upon</span>
<span class="sd">        initialization if they differ from the default options.</span>

<span class="sd">        Args:</span>
<span class="sd">            qpnn: object containing methods to construct the transfer function enacted by a QPNN, and compute the</span>
<span class="sd">                network performance measures</span>
<span class="sd">            num_trials: number of training trials to run</span>
<span class="sd">            num_epochs: number of training epochs to run</span>
<span class="sd">            print_every: specifies how often results should be printed, in terms of epochs</span>
<span class="sd">            sched0: initial value of the exponential decay scheduler used during optimization</span>
<span class="sd">            sched_rate: decay rate of the exponential decay scheduler used during optimization</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_trials</span><span class="p">,</span> <span class="n">num_epochs</span><span class="p">,</span> <span class="n">print_every</span><span class="o">=</span><span class="n">print_every</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">qpnn</span><span class="o">.</span><span class="n">meshes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># store the provided properties of the Imperfect Trainer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span> <span class="o">=</span> <span class="n">qpnn</span>

        <span class="c1"># create the scheduler and optimizer for training</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sched</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">exponential_decay</span><span class="p">(</span><span class="n">init_value</span><span class="o">=</span><span class="n">sched0</span><span class="p">,</span> <span class="n">transition_steps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">,</span> <span class="n">decay_rate</span><span class="o">=</span><span class="n">sched_rate</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opt</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">adam</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sched</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DTypeLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate the cost function that is minimized during training.</span>

<span class="sd">        See `[qpnn](qpnn.md)` for more details on the cost function.</span>

<span class="sd">        Args:</span>
<span class="sd">            phi: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\phi}$, for all MZIs in each of the $L$</span>
<span class="sd">                meshes in the QPNN</span>
<span class="sd">            theta: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\theta}$, for all MZIs in each of the $L$</span>
<span class="sd">                meshes in the QPNN</span>
<span class="sd">            delta: $L\\times m$ array of phase shifts, $\\boldsymbol{\\delta}$, applied in each mode at the output of</span>
<span class="sd">                each of the $L$ meshes in the QPNN</span>

<span class="sd">        Returns:</span>
<span class="sd">            C: cost (i.e. network error) of the QPNN</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Fu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">calc_unc_fidelity</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">Fu</span>  <span class="c1"># type: ignore</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">optstate</span><span class="p">:</span> <span class="n">optax</span><span class="o">.</span><span class="n">OptState</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">DTypeLike</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">jnp_ndarray</span><span class="p">],</span> <span class="n">optax</span><span class="o">.</span><span class="n">OptState</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adjust the variational parameters to minimize the cost function.</span>

<span class="sd">        This method wraps around the `cost` function to evaluate it and its gradients with respect to the variational</span>
<span class="sd">        phase shift parameters. The updates to the parameters are computed using the attribute that stores the</span>
<span class="sd">        optimizer, then applied to the parameters which are subsequently returned alongside the value of the cost</span>
<span class="sd">        function and the state of the optimizer.</span>

<span class="sd">        Args:</span>
<span class="sd">            phi: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\phi}$, for all MZIs in each of the $L$</span>
<span class="sd">                meshes in the QPNN</span>
<span class="sd">            theta: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\theta}$, for all MZIs in each of the $L$</span>
<span class="sd">                meshes in the QPNN</span>
<span class="sd">            delta: $L\\times m$ array of phase shifts, $\\boldsymbol{\\delta}$, applied in each mode at the output of</span>
<span class="sd">                each of the $L$ meshes in the QPNN</span>
<span class="sd">            optstate: current state of the optimizer</span>

<span class="sd">        Returns:</span>
<span class="sd">            C: cost (i.e. network error) of the QPNN</span>
<span class="sd">            Theta: tuple `(phi, theta, delta)` including arrays that store the updated phase shift parameters</span>
<span class="sd">                $(\\boldsymbol{\\phi}, \\boldsymbol{\\theta}, \\boldsymbol{\\delta})$</span>
<span class="sd">            optstate: updated state of the optimizer</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># calculate cost function and its gradient with respect to the 0th, 1st, 2nd parameters,</span>
        <span class="c1"># which are phi, theta,delta respectively</span>
        <span class="n">C</span><span class="p">,</span> <span class="n">grads</span> <span class="o">=</span> <span class="n">value_and_grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cost</span><span class="p">,</span> <span class="n">argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>

        <span class="c1"># calculate updates to the parameters and the state of the optimizer from the gradients, then apply them</span>
        <span class="n">updates</span><span class="p">,</span> <span class="n">optstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="n">optstate</span><span class="p">)</span>
        <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">apply_updates</span><span class="p">((</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">),</span> <span class="n">updates</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">C</span><span class="p">,</span> <span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">),</span> <span class="n">optstate</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Train the QPNN in a number of trials.</span>

<span class="sd">        A dictionary of results is first defined and initialized, then it is iteratively filled by training the given</span>
<span class="sd">        QPNN model in the given number of trials. Each trial, the phase shift parameters are initialized alongside</span>
<span class="sd">        the state of the optimizer, then the parameters are updated iteratively over the given number of epochs.</span>
<span class="sd">        Updates may be printed during training at set intervals of epochs, and at the end of each trial a summary</span>
<span class="sd">        statement is printed as well.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dictionary that contains the relevant results of the training simulation</span>

<span class="sd">                - **&quot;Fu&quot;** (`np_ndarray`): array of network unconditional fidelities at each trial and epoch,</span>
<span class="sd">                    with shape `(num_trials, num_epochs)`</span>
<span class="sd">                - **&quot;Fc&quot;** (`np_ndarray`): array of network conditional fidelities measured at the end of each trial,</span>
<span class="sd">                    with shape `(num_trials,)`</span>
<span class="sd">                - **&quot;rate&quot;** (`np_ndarray`): array of network logical rates measured at the end of each trial,</span>
<span class="sd">                    with shape `(num_trials,)`</span>
<span class="sd">                - **&quot;phi&quot;** (`np_ndarray`): array of optimized phase shifts $\\boldsymbol{\\phi}$ for all training</span>
<span class="sd">                    trials, with shape `(num_trials, L, m * (m - 1) // 2)`</span>
<span class="sd">                - **&quot;theta&quot;** (`np_ndarray`) array of optimized phase shifts $\\boldsymbol{\\theta}$ for all training</span>
<span class="sd">                    trials, with shape `(num_trials, L, m * (m - 1) // 2)`</span>
<span class="sd">                - **&quot;delta&quot;** (`np_ndarray`) array of optimized phase shifts $\\boldsymbol{\\delta}$ for all training</span>
<span class="sd">                    trials, with shape `(num_trials, L, m)`</span>
<span class="sd">                - **&quot;ell_mzi&quot;** (`np_ndarray`) array of fractional losses per arm of each MZI in each QPNN trained in</span>
<span class="sd">                    each trial, with shape `(num_trials, L, m, m)`</span>
<span class="sd">                - **&quot;ell_ps&quot;** (`np_ndarray`) array of fractional losses per mesh output phase shifter in each QPNN</span>
<span class="sd">                    trained in each trial, with shape `(num_trials, L, m)`</span>
<span class="sd">                - **&quot;t_dc&quot;** (`np_ndarray`) array of directional coupler splitting ratios (T:R) throughout each QPNN</span>
<span class="sd">                    trained in each trial, with shape `(num_trials, L, 2, m * (m - 1) // 2)`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># prepare the results dictionary</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;Fu&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
            <span class="s2">&quot;Fc&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
            <span class="s2">&quot;rate&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
            <span class="s2">&quot;phi&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
            <span class="s2">&quot;theta&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
            <span class="s2">&quot;delta&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
            <span class="s2">&quot;ell_mzi&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
            <span class="s2">&quot;ell_ps&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
            <span class="s2">&quot;t_dc&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">trial</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Trial: </span><span class="si">{</span><span class="n">trial</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># refresh the imperfection model for the qpnn if not the first trial</span>
            <span class="k">if</span> <span class="n">trial</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span> <span class="o">=</span> <span class="n">ImperfectQPNN</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">n</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span>
                    <span class="n">varphi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">varphi</span><span class="p">,</span>
                    <span class="n">ell_mzi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">ell_mzi</span><span class="p">,</span>
                    <span class="n">ell_ps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">ell_ps</span><span class="p">,</span>
                    <span class="n">t_dc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">t_dc</span><span class="p">,</span>
                    <span class="n">training_set</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">training_set</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="c1"># prepare the initial parameters and initial state of the optimizer</span>
            <span class="n">Theta0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialize_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
            <span class="n">initial_optstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">Theta0</span><span class="p">)</span>

            <span class="c1"># iterate through the epochs, optimizing the parameters at each iteration</span>
            <span class="n">Theta</span> <span class="o">=</span> <span class="n">Theta0</span>
            <span class="n">optstate</span> <span class="o">=</span> <span class="n">initial_optstate</span>
            <span class="n">Fu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">):</span>
                <span class="n">C</span><span class="p">,</span> <span class="n">Theta</span><span class="p">,</span> <span class="n">optstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="n">Theta</span><span class="p">,</span> <span class="n">optstate</span><span class="p">)</span>
                <span class="n">Fu</span><span class="p">[</span><span class="n">epoch</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">C</span>  <span class="c1"># type: ignore</span>

                <span class="k">if</span> <span class="n">epoch</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_every</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Epoch: </span><span class="si">{</span><span class="n">epoch</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Cost: </span><span class="si">{</span><span class="n">C</span><span class="si">:</span><span class="s2">.4e</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Unconditional Fidelity: </span><span class="si">{</span><span class="n">Fu</span><span class="p">[</span><span class="n">epoch</span><span class="p">]</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># compute performance measures of the trained QPNN</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">Fc</span><span class="p">,</span> <span class="n">rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">calc_performance_measures</span><span class="p">(</span><span class="o">*</span><span class="n">Theta</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;COMPLETE! </span><span class="se">\t</span><span class="s2"> Cost: </span><span class="si">{</span><span class="n">C</span><span class="si">:</span><span class="s2">.4e</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Unconditional Fidelity: </span><span class="si">{</span><span class="n">Fu</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Conditional Fidelity: </span><span class="si">{</span><span class="n">Fc</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Rate: </span><span class="si">{</span><span class="n">rate</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="c1"># store the results from this trial</span>
            <span class="n">results</span><span class="p">[</span><span class="s2">&quot;Fu&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="n">Fu</span>
            <span class="n">results</span><span class="p">[</span><span class="s2">&quot;Fc&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="n">Fc</span>
            <span class="n">results</span><span class="p">[</span><span class="s2">&quot;rate&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="n">rate</span>
            <span class="n">results</span><span class="p">[</span><span class="s2">&quot;phi&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;theta&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;delta&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Theta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">results</span><span class="p">[</span><span class="s2">&quot;ell_mzi&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;ell_ps&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;t_dc&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">imperfections</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-function">


<h3 id="quotonic.trainer.ImperfectTrainer.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">qpnn</span><span class="p">,</span> <span class="n">num_trials</span><span class="p">,</span> <span class="n">num_epochs</span><span class="p">,</span> <span class="n">print_every</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">sched0</span><span class="o">=</span><span class="mf">0.025</span><span class="p">,</span> <span class="n">sched_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span></code>

<a href="#quotonic.trainer.ImperfectTrainer.__init__" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Initialization of an Imperfect Trainer instance.</p>
<p>The exponential decay scheduler and optimizer are initialized here, so desired settings should be passed upon
initialization if they differ from the default options.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>qpnn</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="ImperfectQPNN (quotonic.qpnn.ImperfectQPNN)" href="../qpnn/#quotonic.qpnn.ImperfectQPNN">ImperfectQPNN</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>object containing methods to construct the transfer function enacted by a QPNN, and compute the
network performance measures</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>num_trials</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of training trials to run</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>num_epochs</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of training epochs to run</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>print_every</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>specifies how often results should be printed, in terms of epochs</p>
              </div>
            </td>
            <td>
                  <code>10</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>sched0</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>initial value of the exponential decay scheduler used during optimization</p>
              </div>
            </td>
            <td>
                  <code>0.025</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>sched_rate</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>decay rate of the exponential decay scheduler used during optimization</p>
              </div>
            </td>
            <td>
                  <code>0.1</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/trainer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">qpnn</span><span class="p">:</span> <span class="n">ImperfectQPNN</span><span class="p">,</span>
    <span class="n">num_trials</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">num_epochs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">print_every</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">sched0</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.025</span><span class="p">,</span>
    <span class="n">sched_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialization of an Imperfect Trainer instance.</span>

<span class="sd">    The exponential decay scheduler and optimizer are initialized here, so desired settings should be passed upon</span>
<span class="sd">    initialization if they differ from the default options.</span>

<span class="sd">    Args:</span>
<span class="sd">        qpnn: object containing methods to construct the transfer function enacted by a QPNN, and compute the</span>
<span class="sd">            network performance measures</span>
<span class="sd">        num_trials: number of training trials to run</span>
<span class="sd">        num_epochs: number of training epochs to run</span>
<span class="sd">        print_every: specifies how often results should be printed, in terms of epochs</span>
<span class="sd">        sched0: initial value of the exponential decay scheduler used during optimization</span>
<span class="sd">        sched_rate: decay rate of the exponential decay scheduler used during optimization</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_trials</span><span class="p">,</span> <span class="n">num_epochs</span><span class="p">,</span> <span class="n">print_every</span><span class="o">=</span><span class="n">print_every</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">qpnn</span><span class="o">.</span><span class="n">meshes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># store the provided properties of the Imperfect Trainer</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span> <span class="o">=</span> <span class="n">qpnn</span>

    <span class="c1"># create the scheduler and optimizer for training</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">sched</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">exponential_decay</span><span class="p">(</span><span class="n">init_value</span><span class="o">=</span><span class="n">sched0</span><span class="p">,</span> <span class="n">transition_steps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">,</span> <span class="n">decay_rate</span><span class="o">=</span><span class="n">sched_rate</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">opt</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">adam</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sched</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>






<div class="doc doc-object doc-function">


<h3 id="quotonic.trainer.ImperfectTrainer.cost" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">cost</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span></code>

<a href="#quotonic.trainer.ImperfectTrainer.cost" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Evaluate the cost function that is minimized during training.</p>
<p>See <code>[qpnn](qpnn.md)</code> for more details on the cost function.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>phi</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> array of phase shifts, <span class="arithmatex">\(\boldsymbol{\phi}\)</span>, for all MZIs in each of the <span class="arithmatex">\(L\)</span>
meshes in the QPNN</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>theta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> array of phase shifts, <span class="arithmatex">\(\boldsymbol{\theta}\)</span>, for all MZIs in each of the <span class="arithmatex">\(L\)</span>
meshes in the QPNN</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>delta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m\)</span> array of phase shifts, <span class="arithmatex">\(\boldsymbol{\delta}\)</span>, applied in each mode at the output of
each of the <span class="arithmatex">\(L\)</span> meshes in the QPNN</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>C</code></td>            <td>
                  <code><span title="jax.typing.DTypeLike">DTypeLike</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>cost (i.e. network error) of the QPNN</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/trainer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DTypeLike</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Evaluate the cost function that is minimized during training.</span>

<span class="sd">    See `[qpnn](qpnn.md)` for more details on the cost function.</span>

<span class="sd">    Args:</span>
<span class="sd">        phi: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\phi}$, for all MZIs in each of the $L$</span>
<span class="sd">            meshes in the QPNN</span>
<span class="sd">        theta: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\theta}$, for all MZIs in each of the $L$</span>
<span class="sd">            meshes in the QPNN</span>
<span class="sd">        delta: $L\\times m$ array of phase shifts, $\\boldsymbol{\\delta}$, applied in each mode at the output of</span>
<span class="sd">            each of the $L$ meshes in the QPNN</span>

<span class="sd">    Returns:</span>
<span class="sd">        C: cost (i.e. network error) of the QPNN</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Fu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">calc_unc_fidelity</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">Fu</span>  <span class="c1"># type: ignore</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>






<div class="doc doc-object doc-function">


<h3 id="quotonic.trainer.ImperfectTrainer.update" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">update</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">optstate</span><span class="p">)</span></code>

<a href="#quotonic.trainer.ImperfectTrainer.update" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Adjust the variational parameters to minimize the cost function.</p>
<p>This method wraps around the <code>cost</code> function to evaluate it and its gradients with respect to the variational
phase shift parameters. The updates to the parameters are computed using the attribute that stores the
optimizer, then applied to the parameters which are subsequently returned alongside the value of the cost
function and the state of the optimizer.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>phi</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> array of phase shifts, <span class="arithmatex">\(\boldsymbol{\phi}\)</span>, for all MZIs in each of the <span class="arithmatex">\(L\)</span>
meshes in the QPNN</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>theta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> array of phase shifts, <span class="arithmatex">\(\boldsymbol{\theta}\)</span>, for all MZIs in each of the <span class="arithmatex">\(L\)</span>
meshes in the QPNN</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>delta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m\)</span> array of phase shifts, <span class="arithmatex">\(\boldsymbol{\delta}\)</span>, applied in each mode at the output of
each of the <span class="arithmatex">\(L\)</span> meshes in the QPNN</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>optstate</code>
            </td>
            <td>
                  <code><span title="optax.OptState">OptState</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>current state of the optimizer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>C</code></td>            <td>
                  <code><span title="jax.typing.DTypeLike">DTypeLike</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>cost (i.e. network error) of the QPNN</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>Theta</code></td>            <td>
                  <code><span title="tuple">tuple</span>[<a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a>, <a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a>, <a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple <code>(phi, theta, delta)</code> including arrays that store the updated phase shift parameters
<span class="arithmatex">\((\boldsymbol{\phi}, \boldsymbol{\theta}, \boldsymbol{\delta})\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>optstate</code></td>            <td>
                  <code><span title="optax.OptState">OptState</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>updated state of the optimizer</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/trainer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">optstate</span><span class="p">:</span> <span class="n">optax</span><span class="o">.</span><span class="n">OptState</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">DTypeLike</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">jnp_ndarray</span><span class="p">],</span> <span class="n">optax</span><span class="o">.</span><span class="n">OptState</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adjust the variational parameters to minimize the cost function.</span>

<span class="sd">    This method wraps around the `cost` function to evaluate it and its gradients with respect to the variational</span>
<span class="sd">    phase shift parameters. The updates to the parameters are computed using the attribute that stores the</span>
<span class="sd">    optimizer, then applied to the parameters which are subsequently returned alongside the value of the cost</span>
<span class="sd">    function and the state of the optimizer.</span>

<span class="sd">    Args:</span>
<span class="sd">        phi: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\phi}$, for all MZIs in each of the $L$</span>
<span class="sd">            meshes in the QPNN</span>
<span class="sd">        theta: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\theta}$, for all MZIs in each of the $L$</span>
<span class="sd">            meshes in the QPNN</span>
<span class="sd">        delta: $L\\times m$ array of phase shifts, $\\boldsymbol{\\delta}$, applied in each mode at the output of</span>
<span class="sd">            each of the $L$ meshes in the QPNN</span>
<span class="sd">        optstate: current state of the optimizer</span>

<span class="sd">    Returns:</span>
<span class="sd">        C: cost (i.e. network error) of the QPNN</span>
<span class="sd">        Theta: tuple `(phi, theta, delta)` including arrays that store the updated phase shift parameters</span>
<span class="sd">            $(\\boldsymbol{\\phi}, \\boldsymbol{\\theta}, \\boldsymbol{\\delta})$</span>
<span class="sd">        optstate: updated state of the optimizer</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># calculate cost function and its gradient with respect to the 0th, 1st, 2nd parameters,</span>
    <span class="c1"># which are phi, theta,delta respectively</span>
    <span class="n">C</span><span class="p">,</span> <span class="n">grads</span> <span class="o">=</span> <span class="n">value_and_grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cost</span><span class="p">,</span> <span class="n">argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>

    <span class="c1"># calculate updates to the parameters and the state of the optimizer from the gradients, then apply them</span>
    <span class="n">updates</span><span class="p">,</span> <span class="n">optstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="n">optstate</span><span class="p">)</span>
    <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">apply_updates</span><span class="p">((</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">),</span> <span class="n">updates</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">C</span><span class="p">,</span> <span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">),</span> <span class="n">optstate</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>






<div class="doc doc-object doc-function">


<h3 id="quotonic.trainer.ImperfectTrainer.train" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">train</span><span class="p">()</span></code>

<a href="#quotonic.trainer.ImperfectTrainer.train" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Train the QPNN in a number of trials.</p>
<p>A dictionary of results is first defined and initialized, then it is iteratively filled by training the given
QPNN model in the given number of trials. Each trial, the phase shift parameters are initialized alongside
the state of the optimizer, then the parameters are updated iteratively over the given number of epochs.
Updates may be printed during training at set intervals of epochs, and at the end of each trial a summary
statement is printed as well.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="dict">dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dictionary that contains the relevant results of the training simulation</p>
<ul>
<li><strong>"Fu"</strong> (<code>np_ndarray</code>): array of network unconditional fidelities at each trial and epoch,
    with shape <code>(num_trials, num_epochs)</code></li>
<li><strong>"Fc"</strong> (<code>np_ndarray</code>): array of network conditional fidelities measured at the end of each trial,
    with shape <code>(num_trials,)</code></li>
<li><strong>"rate"</strong> (<code>np_ndarray</code>): array of network logical rates measured at the end of each trial,
    with shape <code>(num_trials,)</code></li>
<li><strong>"phi"</strong> (<code>np_ndarray</code>): array of optimized phase shifts <span class="arithmatex">\(\boldsymbol{\phi}\)</span> for all training
    trials, with shape <code>(num_trials, L, m * (m - 1) // 2)</code></li>
<li><strong>"theta"</strong> (<code>np_ndarray</code>) array of optimized phase shifts <span class="arithmatex">\(\boldsymbol{\theta}\)</span> for all training
    trials, with shape <code>(num_trials, L, m * (m - 1) // 2)</code></li>
<li><strong>"delta"</strong> (<code>np_ndarray</code>) array of optimized phase shifts <span class="arithmatex">\(\boldsymbol{\delta}\)</span> for all training
    trials, with shape <code>(num_trials, L, m)</code></li>
<li><strong>"ell_mzi"</strong> (<code>np_ndarray</code>) array of fractional losses per arm of each MZI in each QPNN trained in
    each trial, with shape <code>(num_trials, L, m, m)</code></li>
<li><strong>"ell_ps"</strong> (<code>np_ndarray</code>) array of fractional losses per mesh output phase shifter in each QPNN
    trained in each trial, with shape <code>(num_trials, L, m)</code></li>
<li><strong>"t_dc"</strong> (<code>np_ndarray</code>) array of directional coupler splitting ratios (T:R) throughout each QPNN
    trained in each trial, with shape <code>(num_trials, L, 2, m * (m - 1) // 2)</code></li>
</ul>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/trainer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Train the QPNN in a number of trials.</span>

<span class="sd">    A dictionary of results is first defined and initialized, then it is iteratively filled by training the given</span>
<span class="sd">    QPNN model in the given number of trials. Each trial, the phase shift parameters are initialized alongside</span>
<span class="sd">    the state of the optimizer, then the parameters are updated iteratively over the given number of epochs.</span>
<span class="sd">    Updates may be printed during training at set intervals of epochs, and at the end of each trial a summary</span>
<span class="sd">    statement is printed as well.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dictionary that contains the relevant results of the training simulation</span>

<span class="sd">            - **&quot;Fu&quot;** (`np_ndarray`): array of network unconditional fidelities at each trial and epoch,</span>
<span class="sd">                with shape `(num_trials, num_epochs)`</span>
<span class="sd">            - **&quot;Fc&quot;** (`np_ndarray`): array of network conditional fidelities measured at the end of each trial,</span>
<span class="sd">                with shape `(num_trials,)`</span>
<span class="sd">            - **&quot;rate&quot;** (`np_ndarray`): array of network logical rates measured at the end of each trial,</span>
<span class="sd">                with shape `(num_trials,)`</span>
<span class="sd">            - **&quot;phi&quot;** (`np_ndarray`): array of optimized phase shifts $\\boldsymbol{\\phi}$ for all training</span>
<span class="sd">                trials, with shape `(num_trials, L, m * (m - 1) // 2)`</span>
<span class="sd">            - **&quot;theta&quot;** (`np_ndarray`) array of optimized phase shifts $\\boldsymbol{\\theta}$ for all training</span>
<span class="sd">                trials, with shape `(num_trials, L, m * (m - 1) // 2)`</span>
<span class="sd">            - **&quot;delta&quot;** (`np_ndarray`) array of optimized phase shifts $\\boldsymbol{\\delta}$ for all training</span>
<span class="sd">                trials, with shape `(num_trials, L, m)`</span>
<span class="sd">            - **&quot;ell_mzi&quot;** (`np_ndarray`) array of fractional losses per arm of each MZI in each QPNN trained in</span>
<span class="sd">                each trial, with shape `(num_trials, L, m, m)`</span>
<span class="sd">            - **&quot;ell_ps&quot;** (`np_ndarray`) array of fractional losses per mesh output phase shifter in each QPNN</span>
<span class="sd">                trained in each trial, with shape `(num_trials, L, m)`</span>
<span class="sd">            - **&quot;t_dc&quot;** (`np_ndarray`) array of directional coupler splitting ratios (T:R) throughout each QPNN</span>
<span class="sd">                trained in each trial, with shape `(num_trials, L, 2, m * (m - 1) // 2)`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># prepare the results dictionary</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;Fu&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="s2">&quot;Fc&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="s2">&quot;rate&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="s2">&quot;phi&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="s2">&quot;theta&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="s2">&quot;delta&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="s2">&quot;ell_mzi&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="s2">&quot;ell_ps&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="s2">&quot;t_dc&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">trial</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Trial: </span><span class="si">{</span><span class="n">trial</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># refresh the imperfection model for the qpnn if not the first trial</span>
        <span class="k">if</span> <span class="n">trial</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span> <span class="o">=</span> <span class="n">ImperfectQPNN</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">n</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span>
                <span class="n">varphi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">varphi</span><span class="p">,</span>
                <span class="n">ell_mzi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">ell_mzi</span><span class="p">,</span>
                <span class="n">ell_ps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">ell_ps</span><span class="p">,</span>
                <span class="n">t_dc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">t_dc</span><span class="p">,</span>
                <span class="n">training_set</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">training_set</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># prepare the initial parameters and initial state of the optimizer</span>
        <span class="n">Theta0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialize_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
        <span class="n">initial_optstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">Theta0</span><span class="p">)</span>

        <span class="c1"># iterate through the epochs, optimizing the parameters at each iteration</span>
        <span class="n">Theta</span> <span class="o">=</span> <span class="n">Theta0</span>
        <span class="n">optstate</span> <span class="o">=</span> <span class="n">initial_optstate</span>
        <span class="n">Fu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">):</span>
            <span class="n">C</span><span class="p">,</span> <span class="n">Theta</span><span class="p">,</span> <span class="n">optstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="n">Theta</span><span class="p">,</span> <span class="n">optstate</span><span class="p">)</span>
            <span class="n">Fu</span><span class="p">[</span><span class="n">epoch</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">C</span>  <span class="c1"># type: ignore</span>

            <span class="k">if</span> <span class="n">epoch</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_every</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Epoch: </span><span class="si">{</span><span class="n">epoch</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Cost: </span><span class="si">{</span><span class="n">C</span><span class="si">:</span><span class="s2">.4e</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Unconditional Fidelity: </span><span class="si">{</span><span class="n">Fu</span><span class="p">[</span><span class="n">epoch</span><span class="p">]</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># compute performance measures of the trained QPNN</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">Fc</span><span class="p">,</span> <span class="n">rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">calc_performance_measures</span><span class="p">(</span><span class="o">*</span><span class="n">Theta</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;COMPLETE! </span><span class="se">\t</span><span class="s2"> Cost: </span><span class="si">{</span><span class="n">C</span><span class="si">:</span><span class="s2">.4e</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Unconditional Fidelity: </span><span class="si">{</span><span class="n">Fu</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Conditional Fidelity: </span><span class="si">{</span><span class="n">Fc</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Rate: </span><span class="si">{</span><span class="n">rate</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="c1"># store the results from this trial</span>
        <span class="n">results</span><span class="p">[</span><span class="s2">&quot;Fu&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="n">Fu</span>
        <span class="n">results</span><span class="p">[</span><span class="s2">&quot;Fc&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="n">Fc</span>
        <span class="n">results</span><span class="p">[</span><span class="s2">&quot;rate&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="n">rate</span>
        <span class="n">results</span><span class="p">[</span><span class="s2">&quot;phi&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;theta&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;delta&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Theta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">results</span><span class="p">[</span><span class="s2">&quot;ell_mzi&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;ell_ps&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;t_dc&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">imperfections</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">results</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>




  </div>

    </div>

</div>






<div class="doc doc-object doc-class">



<h2 id="quotonic.trainer.TreeTrainer" class="doc doc-heading">
            <code>TreeTrainer</code>


<a href="#quotonic.trainer.TreeTrainer" class="headerlink" title="Permanent link">&para;</a></h2>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="Trainer (quotonic.trainer.Trainer)" href="#quotonic.trainer.Trainer">Trainer</a></code></p>


        <p>Class for training imperfect QPNNs based on three-level system photon subtraction/addition nonlinearities that
power a tree-type photonic cluster state generation protocol.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.trainer.TreeTrainer.num_trials">num_trials</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of training trials to run</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.trainer.TreeTrainer.num_epochs">num_epochs</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of training epochs to run</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.trainer.TreeTrainer.print_every">print_every</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>specifies how often results should be printed, in terms of epochs</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.trainer.TreeTrainer.mesh">mesh</span></code></td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="Mesh (quotonic.clements.Mesh)" href="../clements/#quotonic.clements.Mesh">Mesh</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>object containing methods that allow linear layers (i.e. rectangular Mach-Zehnder interferometer
meshes) to be encoded and decoded, taken from TreeQPNN instance</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.trainer.TreeTrainer.qpnn">qpnn</span></code></td>
            <td>
                  <code><span title="TreeQPNNExtended">TreeQPNNExtended</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>object containing methods to construct the transfer function enacted by a QPNN, and
compute the network performance measures</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.trainer.TreeTrainer.sched">sched</span></code></td>
            <td>
                  <code><span title="optax.Schedule">Schedule</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>the exponential decay scheduler used during optimization</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="quotonic.trainer.TreeTrainer.opt">opt</span></code></td>
            <td>
                  <code><span title="optax.GradientTransformation">GradientTransformation</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>the adam optimizer used during optimization</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>








              <details class="quote">
                <summary>Source code in <code>src/quotonic/trainer.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span>
<span class="normal">488</span>
<span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TreeTrainer</span><span class="p">(</span><span class="n">Trainer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Class for training imperfect QPNNs based on three-level system photon subtraction/addition nonlinearities that</span>
<span class="sd">    power a tree-type photonic cluster state generation protocol.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        num_trials (int): number of training trials to run</span>
<span class="sd">        num_epochs (int): number of training epochs to run</span>
<span class="sd">        print_every (int): specifies how often results should be printed, in terms of epochs</span>
<span class="sd">        mesh (Mesh): object containing methods that allow linear layers (i.e. rectangular Mach-Zehnder interferometer</span>
<span class="sd">            meshes) to be encoded and decoded, taken from TreeQPNN instance</span>
<span class="sd">        qpnn (TreeQPNNExtended): object containing methods to construct the transfer function enacted by a QPNN, and</span>
<span class="sd">            compute the network performance measures</span>
<span class="sd">        sched (optax.Schedule): the exponential decay scheduler used during optimization</span>
<span class="sd">        opt (optax.GradientTransformation): the adam optimizer used during optimization</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">qpnn</span><span class="p">:</span> <span class="n">TreeQPNN</span><span class="p">,</span>
        <span class="n">num_trials</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">num_epochs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">print_every</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">sched0</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.025</span><span class="p">,</span>
        <span class="n">sched_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialization of a Tree Trainer instance.</span>

<span class="sd">        The exponential decay scheduler and optimizer are initialized here, so desired settings should be passed upon</span>
<span class="sd">        initialization if they differ from the default options.</span>

<span class="sd">        Args:</span>
<span class="sd">            qpnn: object containing methods to construct the transfer function enacted by a QPNN, and compute the</span>
<span class="sd">                network performance measures</span>
<span class="sd">            num_trials: number of training trials to run</span>
<span class="sd">            num_epochs: number of training epochs to run</span>
<span class="sd">            print_every: specifies how often results should be printed, in terms of epochs</span>
<span class="sd">            sched0: initial value of the exponential decay scheduler used during optimization</span>
<span class="sd">            sched_rate: decay rate of the exponential decay scheduler used during optimization</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_trials</span><span class="p">,</span> <span class="n">num_epochs</span><span class="p">,</span> <span class="n">print_every</span><span class="o">=</span><span class="n">print_every</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">qpnn</span><span class="o">.</span><span class="n">meshes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># store the provided properties of the Tree Trainer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span> <span class="o">=</span> <span class="n">qpnn</span>

        <span class="c1"># create the scheduler and optimizer for training</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sched</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">exponential_decay</span><span class="p">(</span><span class="n">init_value</span><span class="o">=</span><span class="n">sched0</span><span class="p">,</span> <span class="n">transition_steps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">,</span> <span class="n">decay_rate</span><span class="o">=</span><span class="n">sched_rate</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opt</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">adam</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sched</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DTypeLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate the cost function that is minimized during training.</span>

<span class="sd">        See `[qpnn](qpnn.md)` for more details on the cost function.</span>

<span class="sd">        Args:</span>
<span class="sd">            phi: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\phi}$, for all MZIs in each of the $L$</span>
<span class="sd">                meshes in the QPNN</span>
<span class="sd">            theta: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\theta}$, for all MZIs in each of the $L$</span>
<span class="sd">                meshes in the QPNN</span>
<span class="sd">            delta: $L\\times m$ array of phase shifts, $\\boldsymbol{\\delta}$, applied in each mode at the output of</span>
<span class="sd">                each of the $L$ meshes in the QPNN</span>

<span class="sd">        Returns:</span>
<span class="sd">            C: cost (i.e. network error) of the QPNN</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">calc_cost</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cost</span>  <span class="c1"># type: ignore</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">optstate</span><span class="p">:</span> <span class="n">optax</span><span class="o">.</span><span class="n">OptState</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">DTypeLike</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">jnp_ndarray</span><span class="p">],</span> <span class="n">optax</span><span class="o">.</span><span class="n">OptState</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Adjust the variational parameters to minimize the cost function.</span>

<span class="sd">        This method wraps around the `cost` function to evaluate it and its gradients with respect to the variational</span>
<span class="sd">        phase shift parameters. The updates to the parameters are computed using the attribute that stores the</span>
<span class="sd">        optimizer, then applied to the parameters which are subsequently returned alongside the value of the cost</span>
<span class="sd">        function and the state of the optimizer.</span>

<span class="sd">        Args:</span>
<span class="sd">            phi: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\phi}$, for all MZIs in each of the $L$</span>
<span class="sd">                meshes in the QPNN</span>
<span class="sd">            theta: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\theta}$, for all MZIs in each of the $L$</span>
<span class="sd">                meshes in the QPNN</span>
<span class="sd">            delta: $L\\times m$ array of phase shifts, $\\boldsymbol{\\delta}$, applied in each mode at the output of</span>
<span class="sd">                each of the $L$ meshes in the QPNN</span>
<span class="sd">            optstate: current state of the optimizer</span>

<span class="sd">        Returns:</span>
<span class="sd">            C: cost (i.e. network error) of the QPNN</span>
<span class="sd">            Theta: tuple `(phi, theta, delta)` including arrays that store the updated phase shift parameters</span>
<span class="sd">                $(\\boldsymbol{\\phi}, \\boldsymbol{\\theta}, \\boldsymbol{\\delta})$</span>
<span class="sd">            optstate: updated state of the optimizer</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># calculate cost function and its gradient with respect to the 0th, 1st, 2nd parameters,</span>
        <span class="c1"># which are phi, theta, delta respectively</span>
        <span class="n">C</span><span class="p">,</span> <span class="n">grads</span> <span class="o">=</span> <span class="n">value_and_grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cost</span><span class="p">,</span> <span class="n">argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>

        <span class="c1"># calculate updates to the parameters and the state of the optimizer from the gradients, then apply them</span>
        <span class="n">updates</span><span class="p">,</span> <span class="n">optstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="n">optstate</span><span class="p">)</span>
        <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">apply_updates</span><span class="p">((</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">),</span> <span class="n">updates</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">C</span><span class="p">,</span> <span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">),</span> <span class="n">optstate</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Train the QPNN in a number of trials.</span>

<span class="sd">        A dictionary of results is first defined and initialized, then it is iteratively filled by training the given</span>
<span class="sd">        QPNN model in the given number of trials. Each trial, the phase shift parameters are initialized alongside</span>
<span class="sd">        the state of the optimizer, then the parameters are updated iteratively over the given number of epochs.</span>
<span class="sd">        Updates may be printed during training at set intervals of epochs, and at the end of each trial a summary</span>
<span class="sd">        statement is printed as well.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dictionary that contains the relevant results of the training simulation</span>

<span class="sd">                - **&quot;cost&quot;** (`np_ndarray`): array of network cost function values at each trial and epoch,</span>
<span class="sd">                    with shape `(num_trials, num_epochs)`</span>
<span class="sd">                - **&quot;fid&quot;** (`np_ndarray`): array of network fidelities measured at the end of each trial,</span>
<span class="sd">                    with shape `(num_trials,)`</span>
<span class="sd">                - **&quot;succ_rate&quot;** (`np_ndarray`): array of network success rates measured at the end of each trial,</span>
<span class="sd">                    with shape `(num_trials,)`</span>
<span class="sd">                - **&quot;logi_rate&quot;** (`np_ndarray`): array of network logical rates measured at the end of each trial,</span>
<span class="sd">                    with shape `(num_trials,)`</span>
<span class="sd">                - **&quot;phi&quot;** (`np_ndarray`): array of optimized phase shifts $\\boldsymbol{\\phi}$ for all training</span>
<span class="sd">                    trials, with shape `(num_trials, L, m * (m - 1) // 2)`</span>
<span class="sd">                - **&quot;theta&quot;** (`np_ndarray`) array of optimized phase shifts $\\boldsymbol{\\theta}$ for all training</span>
<span class="sd">                    trials, with shape `(num_trials, L, m * (m - 1) // 2)`</span>
<span class="sd">                - **&quot;delta&quot;** (`np_ndarray`) array of optimized phase shifts $\\boldsymbol{\\delta}$ for all training</span>
<span class="sd">                    trials, with shape `(num_trials, L, m)`</span>
<span class="sd">                - **&quot;ell_mzi&quot;** (`np_ndarray`) array of fractional losses per arm of each MZI in each QPNN trained in</span>
<span class="sd">                    each trial, with shape `(num_trials, L, m, m)`</span>
<span class="sd">                - **&quot;ell_ps&quot;** (`np_ndarray`) array of fractional losses per mesh output phase shifter in each QPNN</span>
<span class="sd">                    trained in each trial, with shape `(num_trials, L, m)`</span>
<span class="sd">                - **&quot;t_dc&quot;** (`np_ndarray`) array of directional coupler splitting ratios (T:R) throughout each QPNN</span>
<span class="sd">                    trained in each trial, with shape `(num_trials, L, 2, m * (m - 1) // 2)`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># prepare the results dictionary</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;cost&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
            <span class="s2">&quot;fid&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
            <span class="s2">&quot;succ_rate&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
            <span class="s2">&quot;logi_rate&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
            <span class="s2">&quot;phi&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
            <span class="s2">&quot;theta&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
            <span class="s2">&quot;delta&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
            <span class="s2">&quot;ell_mzi&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
            <span class="s2">&quot;ell_ps&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
            <span class="s2">&quot;t_dc&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">trial</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Trial: </span><span class="si">{</span><span class="n">trial</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># refresh the imperfection model for the qpnn if not the first trial</span>
            <span class="k">if</span> <span class="n">trial</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span> <span class="o">=</span> <span class="n">TreeQPNN</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">b</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span>
                    <span class="n">varphi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">varphi</span><span class="p">,</span>
                    <span class="n">ell_mzi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">ell_mzi</span><span class="p">,</span>
                    <span class="n">ell_ps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">ell_ps</span><span class="p">,</span>
                    <span class="n">t_dc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">t_dc</span><span class="p">,</span>
                    <span class="n">training_set</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">training_set</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="c1"># prepare the initial parameters and initial state of the optimizer</span>
            <span class="n">Theta0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialize_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
            <span class="n">initial_optstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">Theta0</span><span class="p">)</span>

            <span class="c1"># iterate through the epochs, optimizing the parameters at each iteration</span>
            <span class="n">Theta</span> <span class="o">=</span> <span class="n">Theta0</span>
            <span class="n">optstate</span> <span class="o">=</span> <span class="n">initial_optstate</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">C</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">):</span>
                <span class="n">C</span><span class="p">,</span> <span class="n">Theta</span><span class="p">,</span> <span class="n">optstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="n">Theta</span><span class="p">,</span> <span class="n">optstate</span><span class="p">)</span>
                <span class="n">cost</span><span class="p">[</span><span class="n">epoch</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span>  <span class="c1"># type: ignore</span>

                <span class="k">if</span> <span class="n">epoch</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_every</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Epoch: </span><span class="si">{</span><span class="n">epoch</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Cost: </span><span class="si">{</span><span class="n">C</span><span class="si">:</span><span class="s2">.4e</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Success Rate: </span><span class="si">{</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">cost</span><span class="p">[</span><span class="n">epoch</span><span class="p">]</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># compute performance measures of the trained QPNN</span>
            <span class="n">fid</span><span class="p">,</span> <span class="n">succ_rate</span><span class="p">,</span> <span class="n">logi_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">calc_overall_performance_measures</span><span class="p">(</span><span class="o">*</span><span class="n">Theta</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;COMPLETE! </span><span class="se">\t</span><span class="s2"> Cost: </span><span class="si">{</span><span class="n">C</span><span class="si">:</span><span class="s2">.4e</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Fid: </span><span class="si">{</span><span class="n">fid</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Succ: </span><span class="si">{</span><span class="n">succ_rate</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Logi: </span><span class="si">{</span><span class="n">logi_rate</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># store the results from this trial</span>
            <span class="n">results</span><span class="p">[</span><span class="s2">&quot;cost&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span>
            <span class="n">results</span><span class="p">[</span><span class="s2">&quot;fid&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="n">fid</span>
            <span class="n">results</span><span class="p">[</span><span class="s2">&quot;succ_rate&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="n">succ_rate</span>
            <span class="n">results</span><span class="p">[</span><span class="s2">&quot;logi_rate&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="n">logi_rate</span>
            <span class="n">results</span><span class="p">[</span><span class="s2">&quot;phi&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;theta&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;delta&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Theta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">results</span><span class="p">[</span><span class="s2">&quot;ell_mzi&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;ell_ps&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;t_dc&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">imperfections</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-function">


<h3 id="quotonic.trainer.TreeTrainer.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">qpnn</span><span class="p">,</span> <span class="n">num_trials</span><span class="p">,</span> <span class="n">num_epochs</span><span class="p">,</span> <span class="n">print_every</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">sched0</span><span class="o">=</span><span class="mf">0.025</span><span class="p">,</span> <span class="n">sched_rate</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span></code>

<a href="#quotonic.trainer.TreeTrainer.__init__" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Initialization of a Tree Trainer instance.</p>
<p>The exponential decay scheduler and optimizer are initialized here, so desired settings should be passed upon
initialization if they differ from the default options.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>qpnn</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="TreeQPNN (quotonic.qpnn.TreeQPNN)" href="../qpnn/#quotonic.qpnn.TreeQPNN">TreeQPNN</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>object containing methods to construct the transfer function enacted by a QPNN, and compute the
network performance measures</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>num_trials</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of training trials to run</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>num_epochs</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>number of training epochs to run</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>print_every</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>specifies how often results should be printed, in terms of epochs</p>
              </div>
            </td>
            <td>
                  <code>10</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>sched0</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>initial value of the exponential decay scheduler used during optimization</p>
              </div>
            </td>
            <td>
                  <code>0.025</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>sched_rate</code>
            </td>
            <td>
                  <code><span title="float">float</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>decay rate of the exponential decay scheduler used during optimization</p>
              </div>
            </td>
            <td>
                  <code>0.1</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/trainer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">489</span>
<span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span>
<span class="normal">499</span>
<span class="normal">500</span>
<span class="normal">501</span>
<span class="normal">502</span>
<span class="normal">503</span>
<span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">qpnn</span><span class="p">:</span> <span class="n">TreeQPNN</span><span class="p">,</span>
    <span class="n">num_trials</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">num_epochs</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">print_every</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">sched0</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.025</span><span class="p">,</span>
    <span class="n">sched_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialization of a Tree Trainer instance.</span>

<span class="sd">    The exponential decay scheduler and optimizer are initialized here, so desired settings should be passed upon</span>
<span class="sd">    initialization if they differ from the default options.</span>

<span class="sd">    Args:</span>
<span class="sd">        qpnn: object containing methods to construct the transfer function enacted by a QPNN, and compute the</span>
<span class="sd">            network performance measures</span>
<span class="sd">        num_trials: number of training trials to run</span>
<span class="sd">        num_epochs: number of training epochs to run</span>
<span class="sd">        print_every: specifies how often results should be printed, in terms of epochs</span>
<span class="sd">        sched0: initial value of the exponential decay scheduler used during optimization</span>
<span class="sd">        sched_rate: decay rate of the exponential decay scheduler used during optimization</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">num_trials</span><span class="p">,</span> <span class="n">num_epochs</span><span class="p">,</span> <span class="n">print_every</span><span class="o">=</span><span class="n">print_every</span><span class="p">,</span> <span class="n">mesh</span><span class="o">=</span><span class="n">qpnn</span><span class="o">.</span><span class="n">meshes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># store the provided properties of the Tree Trainer</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span> <span class="o">=</span> <span class="n">qpnn</span>

    <span class="c1"># create the scheduler and optimizer for training</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">sched</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">exponential_decay</span><span class="p">(</span><span class="n">init_value</span><span class="o">=</span><span class="n">sched0</span><span class="p">,</span> <span class="n">transition_steps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">,</span> <span class="n">decay_rate</span><span class="o">=</span><span class="n">sched_rate</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">opt</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">adam</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sched</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>






<div class="doc doc-object doc-function">


<h3 id="quotonic.trainer.TreeTrainer.cost" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">cost</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span></code>

<a href="#quotonic.trainer.TreeTrainer.cost" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Evaluate the cost function that is minimized during training.</p>
<p>See <code>[qpnn](qpnn.md)</code> for more details on the cost function.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>phi</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> array of phase shifts, <span class="arithmatex">\(\boldsymbol{\phi}\)</span>, for all MZIs in each of the <span class="arithmatex">\(L\)</span>
meshes in the QPNN</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>theta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> array of phase shifts, <span class="arithmatex">\(\boldsymbol{\theta}\)</span>, for all MZIs in each of the <span class="arithmatex">\(L\)</span>
meshes in the QPNN</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>delta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m\)</span> array of phase shifts, <span class="arithmatex">\(\boldsymbol{\delta}\)</span>, applied in each mode at the output of
each of the <span class="arithmatex">\(L\)</span> meshes in the QPNN</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>C</code></td>            <td>
                  <code><span title="jax.typing.DTypeLike">DTypeLike</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>cost (i.e. network error) of the QPNN</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/trainer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DTypeLike</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Evaluate the cost function that is minimized during training.</span>

<span class="sd">    See `[qpnn](qpnn.md)` for more details on the cost function.</span>

<span class="sd">    Args:</span>
<span class="sd">        phi: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\phi}$, for all MZIs in each of the $L$</span>
<span class="sd">            meshes in the QPNN</span>
<span class="sd">        theta: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\theta}$, for all MZIs in each of the $L$</span>
<span class="sd">            meshes in the QPNN</span>
<span class="sd">        delta: $L\\times m$ array of phase shifts, $\\boldsymbol{\\delta}$, applied in each mode at the output of</span>
<span class="sd">            each of the $L$ meshes in the QPNN</span>

<span class="sd">    Returns:</span>
<span class="sd">        C: cost (i.e. network error) of the QPNN</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">calc_cost</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cost</span>  <span class="c1"># type: ignore</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>






<div class="doc doc-object doc-function">


<h3 id="quotonic.trainer.TreeTrainer.update" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">update</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">optstate</span><span class="p">)</span></code>

<a href="#quotonic.trainer.TreeTrainer.update" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Adjust the variational parameters to minimize the cost function.</p>
<p>This method wraps around the <code>cost</code> function to evaluate it and its gradients with respect to the variational
phase shift parameters. The updates to the parameters are computed using the attribute that stores the
optimizer, then applied to the parameters which are subsequently returned alongside the value of the cost
function and the state of the optimizer.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>phi</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> array of phase shifts, <span class="arithmatex">\(\boldsymbol{\phi}\)</span>, for all MZIs in each of the <span class="arithmatex">\(L\)</span>
meshes in the QPNN</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>theta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m(m-1)/2\)</span> array of phase shifts, <span class="arithmatex">\(\boldsymbol{\theta}\)</span>, for all MZIs in each of the <span class="arithmatex">\(L\)</span>
meshes in the QPNN</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>delta</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><span class="arithmatex">\(L\times m\)</span> array of phase shifts, <span class="arithmatex">\(\boldsymbol{\delta}\)</span>, applied in each mode at the output of
each of the <span class="arithmatex">\(L\)</span> meshes in the QPNN</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>optstate</code>
            </td>
            <td>
                  <code><span title="optax.OptState">OptState</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>current state of the optimizer</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>C</code></td>            <td>
                  <code><span title="jax.typing.DTypeLike">DTypeLike</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>cost (i.e. network error) of the QPNN</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>Theta</code></td>            <td>
                  <code><span title="tuple">tuple</span>[<a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a>, <a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a>, <a class="autorefs autorefs-internal" title="jnp_ndarray = jnp.ndarray

  
      module-attribute
   (quotonic.types.jnp_ndarray)" href="../types/#quotonic.types.jnp_ndarray">jnp_ndarray</a>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>tuple <code>(phi, theta, delta)</code> including arrays that store the updated phase shift parameters
<span class="arithmatex">\((\boldsymbol{\phi}, \boldsymbol{\theta}, \boldsymbol{\delta})\)</span></p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
<td><code>optstate</code></td>            <td>
                  <code><span title="optax.OptState">OptState</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>updated state of the optimizer</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/trainer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span> <span class="n">phi</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">theta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">optstate</span><span class="p">:</span> <span class="n">optax</span><span class="o">.</span><span class="n">OptState</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">DTypeLike</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">jnp_ndarray</span><span class="p">,</span> <span class="n">jnp_ndarray</span><span class="p">],</span> <span class="n">optax</span><span class="o">.</span><span class="n">OptState</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adjust the variational parameters to minimize the cost function.</span>

<span class="sd">    This method wraps around the `cost` function to evaluate it and its gradients with respect to the variational</span>
<span class="sd">    phase shift parameters. The updates to the parameters are computed using the attribute that stores the</span>
<span class="sd">    optimizer, then applied to the parameters which are subsequently returned alongside the value of the cost</span>
<span class="sd">    function and the state of the optimizer.</span>

<span class="sd">    Args:</span>
<span class="sd">        phi: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\phi}$, for all MZIs in each of the $L$</span>
<span class="sd">            meshes in the QPNN</span>
<span class="sd">        theta: $L\\times m(m-1)/2$ array of phase shifts, $\\boldsymbol{\\theta}$, for all MZIs in each of the $L$</span>
<span class="sd">            meshes in the QPNN</span>
<span class="sd">        delta: $L\\times m$ array of phase shifts, $\\boldsymbol{\\delta}$, applied in each mode at the output of</span>
<span class="sd">            each of the $L$ meshes in the QPNN</span>
<span class="sd">        optstate: current state of the optimizer</span>

<span class="sd">    Returns:</span>
<span class="sd">        C: cost (i.e. network error) of the QPNN</span>
<span class="sd">        Theta: tuple `(phi, theta, delta)` including arrays that store the updated phase shift parameters</span>
<span class="sd">            $(\\boldsymbol{\\phi}, \\boldsymbol{\\theta}, \\boldsymbol{\\delta})$</span>
<span class="sd">        optstate: updated state of the optimizer</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># calculate cost function and its gradient with respect to the 0th, 1st, 2nd parameters,</span>
    <span class="c1"># which are phi, theta, delta respectively</span>
    <span class="n">C</span><span class="p">,</span> <span class="n">grads</span> <span class="o">=</span> <span class="n">value_and_grad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cost</span><span class="p">,</span> <span class="n">argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>

    <span class="c1"># calculate updates to the parameters and the state of the optimizer from the gradients, then apply them</span>
    <span class="n">updates</span><span class="p">,</span> <span class="n">optstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="n">optstate</span><span class="p">)</span>
    <span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">apply_updates</span><span class="p">((</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">),</span> <span class="n">updates</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">C</span><span class="p">,</span> <span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">delta</span><span class="p">),</span> <span class="n">optstate</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>






<div class="doc doc-object doc-function">


<h3 id="quotonic.trainer.TreeTrainer.train" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">train</span><span class="p">()</span></code>

<a href="#quotonic.trainer.TreeTrainer.train" class="headerlink" title="Permanent link">&para;</a></h3>


    <div class="doc doc-contents ">

        <p>Train the QPNN in a number of trials.</p>
<p>A dictionary of results is first defined and initialized, then it is iteratively filled by training the given
QPNN model in the given number of trials. Each trial, the phase shift parameters are initialized alongside
the state of the optimizer, then the parameters are updated iteratively over the given number of epochs.
Updates may be printed during training at set intervals of epochs, and at the end of each trial a summary
statement is printed as well.</p>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="dict">dict</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dictionary that contains the relevant results of the training simulation</p>
<ul>
<li><strong>"cost"</strong> (<code>np_ndarray</code>): array of network cost function values at each trial and epoch,
    with shape <code>(num_trials, num_epochs)</code></li>
<li><strong>"fid"</strong> (<code>np_ndarray</code>): array of network fidelities measured at the end of each trial,
    with shape <code>(num_trials,)</code></li>
<li><strong>"succ_rate"</strong> (<code>np_ndarray</code>): array of network success rates measured at the end of each trial,
    with shape <code>(num_trials,)</code></li>
<li><strong>"logi_rate"</strong> (<code>np_ndarray</code>): array of network logical rates measured at the end of each trial,
    with shape <code>(num_trials,)</code></li>
<li><strong>"phi"</strong> (<code>np_ndarray</code>): array of optimized phase shifts <span class="arithmatex">\(\boldsymbol{\phi}\)</span> for all training
    trials, with shape <code>(num_trials, L, m * (m - 1) // 2)</code></li>
<li><strong>"theta"</strong> (<code>np_ndarray</code>) array of optimized phase shifts <span class="arithmatex">\(\boldsymbol{\theta}\)</span> for all training
    trials, with shape <code>(num_trials, L, m * (m - 1) // 2)</code></li>
<li><strong>"delta"</strong> (<code>np_ndarray</code>) array of optimized phase shifts <span class="arithmatex">\(\boldsymbol{\delta}\)</span> for all training
    trials, with shape <code>(num_trials, L, m)</code></li>
<li><strong>"ell_mzi"</strong> (<code>np_ndarray</code>) array of fractional losses per arm of each MZI in each QPNN trained in
    each trial, with shape <code>(num_trials, L, m, m)</code></li>
<li><strong>"ell_ps"</strong> (<code>np_ndarray</code>) array of fractional losses per mesh output phase shifter in each QPNN
    trained in each trial, with shape <code>(num_trials, L, m)</code></li>
<li><strong>"t_dc"</strong> (<code>np_ndarray</code>) array of directional coupler splitting ratios (T:R) throughout each QPNN
    trained in each trial, with shape <code>(num_trials, L, 2, m * (m - 1) // 2)</code></li>
</ul>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/quotonic/trainer.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span>
<span class="normal">630</span>
<span class="normal">631</span>
<span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span>
<span class="normal">672</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Train the QPNN in a number of trials.</span>

<span class="sd">    A dictionary of results is first defined and initialized, then it is iteratively filled by training the given</span>
<span class="sd">    QPNN model in the given number of trials. Each trial, the phase shift parameters are initialized alongside</span>
<span class="sd">    the state of the optimizer, then the parameters are updated iteratively over the given number of epochs.</span>
<span class="sd">    Updates may be printed during training at set intervals of epochs, and at the end of each trial a summary</span>
<span class="sd">    statement is printed as well.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Dictionary that contains the relevant results of the training simulation</span>

<span class="sd">            - **&quot;cost&quot;** (`np_ndarray`): array of network cost function values at each trial and epoch,</span>
<span class="sd">                with shape `(num_trials, num_epochs)`</span>
<span class="sd">            - **&quot;fid&quot;** (`np_ndarray`): array of network fidelities measured at the end of each trial,</span>
<span class="sd">                with shape `(num_trials,)`</span>
<span class="sd">            - **&quot;succ_rate&quot;** (`np_ndarray`): array of network success rates measured at the end of each trial,</span>
<span class="sd">                with shape `(num_trials,)`</span>
<span class="sd">            - **&quot;logi_rate&quot;** (`np_ndarray`): array of network logical rates measured at the end of each trial,</span>
<span class="sd">                with shape `(num_trials,)`</span>
<span class="sd">            - **&quot;phi&quot;** (`np_ndarray`): array of optimized phase shifts $\\boldsymbol{\\phi}$ for all training</span>
<span class="sd">                trials, with shape `(num_trials, L, m * (m - 1) // 2)`</span>
<span class="sd">            - **&quot;theta&quot;** (`np_ndarray`) array of optimized phase shifts $\\boldsymbol{\\theta}$ for all training</span>
<span class="sd">                trials, with shape `(num_trials, L, m * (m - 1) // 2)`</span>
<span class="sd">            - **&quot;delta&quot;** (`np_ndarray`) array of optimized phase shifts $\\boldsymbol{\\delta}$ for all training</span>
<span class="sd">                trials, with shape `(num_trials, L, m)`</span>
<span class="sd">            - **&quot;ell_mzi&quot;** (`np_ndarray`) array of fractional losses per arm of each MZI in each QPNN trained in</span>
<span class="sd">                each trial, with shape `(num_trials, L, m, m)`</span>
<span class="sd">            - **&quot;ell_ps&quot;** (`np_ndarray`) array of fractional losses per mesh output phase shifter in each QPNN</span>
<span class="sd">                trained in each trial, with shape `(num_trials, L, m)`</span>
<span class="sd">            - **&quot;t_dc&quot;** (`np_ndarray`) array of directional coupler splitting ratios (T:R) throughout each QPNN</span>
<span class="sd">                trained in each trial, with shape `(num_trials, L, 2, m * (m - 1) // 2)`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># prepare the results dictionary</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;cost&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="s2">&quot;fid&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="s2">&quot;succ_rate&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="s2">&quot;logi_rate&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="s2">&quot;phi&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="s2">&quot;theta&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="s2">&quot;delta&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="s2">&quot;ell_mzi&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="s2">&quot;ell_ps&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
        <span class="s2">&quot;t_dc&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">trial</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_trials</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Trial: </span><span class="si">{</span><span class="n">trial</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># refresh the imperfection model for the qpnn if not the first trial</span>
        <span class="k">if</span> <span class="n">trial</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span> <span class="o">=</span> <span class="n">TreeQPNN</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">b</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">,</span>
                <span class="n">varphi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">varphi</span><span class="p">,</span>
                <span class="n">ell_mzi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">ell_mzi</span><span class="p">,</span>
                <span class="n">ell_ps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">ell_ps</span><span class="p">,</span>
                <span class="n">t_dc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">t_dc</span><span class="p">,</span>
                <span class="n">training_set</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">training_set</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># prepare the initial parameters and initial state of the optimizer</span>
        <span class="n">Theta0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initialize_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">L</span><span class="p">)</span>
        <span class="n">initial_optstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">opt</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">Theta0</span><span class="p">)</span>

        <span class="c1"># iterate through the epochs, optimizing the parameters at each iteration</span>
        <span class="n">Theta</span> <span class="o">=</span> <span class="n">Theta0</span>
        <span class="n">optstate</span> <span class="o">=</span> <span class="n">initial_optstate</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">C</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_epochs</span><span class="p">):</span>
            <span class="n">C</span><span class="p">,</span> <span class="n">Theta</span><span class="p">,</span> <span class="n">optstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="n">Theta</span><span class="p">,</span> <span class="n">optstate</span><span class="p">)</span>
            <span class="n">cost</span><span class="p">[</span><span class="n">epoch</span><span class="p">]</span> <span class="o">=</span> <span class="n">C</span>  <span class="c1"># type: ignore</span>

            <span class="k">if</span> <span class="n">epoch</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_every</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Epoch: </span><span class="si">{</span><span class="n">epoch</span><span class="si">:</span><span class="s2">d</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Cost: </span><span class="si">{</span><span class="n">C</span><span class="si">:</span><span class="s2">.4e</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Success Rate: </span><span class="si">{</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">cost</span><span class="p">[</span><span class="n">epoch</span><span class="p">]</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># compute performance measures of the trained QPNN</span>
        <span class="n">fid</span><span class="p">,</span> <span class="n">succ_rate</span><span class="p">,</span> <span class="n">logi_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">calc_overall_performance_measures</span><span class="p">(</span><span class="o">*</span><span class="n">Theta</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;COMPLETE! </span><span class="se">\t</span><span class="s2"> Cost: </span><span class="si">{</span><span class="n">C</span><span class="si">:</span><span class="s2">.4e</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Fid: </span><span class="si">{</span><span class="n">fid</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Succ: </span><span class="si">{</span><span class="n">succ_rate</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2"> </span><span class="se">\t</span><span class="s2"> Logi: </span><span class="si">{</span><span class="n">logi_rate</span><span class="si">:</span><span class="s2">.4g</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># store the results from this trial</span>
        <span class="n">results</span><span class="p">[</span><span class="s2">&quot;cost&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span>
        <span class="n">results</span><span class="p">[</span><span class="s2">&quot;fid&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="n">fid</span>
        <span class="n">results</span><span class="p">[</span><span class="s2">&quot;succ_rate&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="n">succ_rate</span>
        <span class="n">results</span><span class="p">[</span><span class="s2">&quot;logi_rate&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="n">logi_rate</span>
        <span class="n">results</span><span class="p">[</span><span class="s2">&quot;phi&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;theta&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;delta&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Theta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">results</span><span class="p">[</span><span class="s2">&quot;ell_mzi&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;ell_ps&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">],</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;t_dc&quot;</span><span class="p">][</span><span class="n">trial</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qpnn</span><span class="o">.</span><span class="n">imperfections</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">results</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>




  </div>

    </div>

</div>




  </div>

    </div>

</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"/></svg>
  Back to top
</button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Maintained by <a href="https://www.linkedin.com/in/jacobewaniuk/">Jacob Ewaniuk</a>.
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
        
<div class="md-social">
  
    
    
    
    
      
      
    
    <a href="https://github.com/jewaniuk/quotonic" target="_blank" rel="noopener" title="github.com" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M173.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M252.8 8C114.1 8 8 113.3 8 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C436.2 457.8 504 362.9 504 252 504 113.3 391.5 8 252.8 8M105.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"/></svg>
    </a>
  
    
    
    
    
      
      
    
    <a href="https://pypi.org/project/quotonic" target="_blank" rel="noopener" title="pypi.org" class="md-social__link">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.1.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path d="M439.8 200.5c-7.7-30.9-22.3-54.2-53.4-54.2h-40.1v47.4c0 36.8-31.2 67.8-66.8 67.8H172.7c-29.2 0-53.4 25-53.4 54.3v101.8c0 29 25.2 46 53.4 54.3 33.8 9.9 66.3 11.7 106.8 0 26.9-7.8 53.4-23.5 53.4-54.3v-40.7H226.2v-13.6h160.2c31.1 0 42.6-21.7 53.4-54.2 11.2-33.5 10.7-65.7 0-108.6M286.2 444.7a20.4 20.4 0 1 1 0-40.7 20.4 20.4 0 1 1 0 40.7M167.8 248.1h106.8c29.7 0 53.4-24.5 53.4-54.3V91.9c0-29-24.4-50.7-53.4-55.6-35.8-5.9-74.7-5.6-106.8.1-45.2 8-53.4 24.7-53.4 55.6v40.7h106.9v13.6h-147c-31.1 0-58.3 18.7-66.8 54.2-9.8 40.7-10.2 66.1 0 108.6 7.6 31.6 25.7 54.2 56.8 54.2H101v-48.8c0-35.3 30.5-66.4 66.8-66.4m-6.6-183.4a20.4 20.4 0 1 1 0 40.8 20.4 20.4 0 1 1 0-40.8"/></svg>
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "..", "features": ["navigation.sections", "navigation.tracking", "toc.integrate", "navigation.instant", "navigation.top", "navigation.tabs", "navigation.prune"], "search": "../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": {"provider": "mike"}}</script>
    
    
      <script src="../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
        <script src="../js/katex.js"></script>
      
        <script src="https://unpkg.com/katex@0/dist/katex.min.js"></script>
      
        <script src="https://unpkg.com/katex@0/dist/contrib/auto-render.min.js"></script>
      
    
  </body>
</html>